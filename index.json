[{"categories":["数据结构和算法"],"content":"四种常见的二分查找变形问题 ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:0","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"1、查找第一个值等于给定值的元素 func main() { arr := []int{1, 3, 4, 5, 6, 8, 8, 8, 11, 18} target := 8 log.Println(bsearch(arr, target)) } // 查找第一个值等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 // 顺序数组 // 直接索引取值 // 终止条件 for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if arr[mid] \u003e target { high = mid - 1 } else if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid-1] != target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:1","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"2、查找最后一个值等于给定值的元素 // 查找最后一个值等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 // 顺序数组 // 直接索引取值 // 终止条件 for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if arr[mid] \u003e target { high = mid - 1 } else if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid+1] != target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:2","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"3、查找第一个大于等于给定值的元素 // 查找第一个大于等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid - 1] \u003c target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:3","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"4、查找最后一个小于等于给定值的元素 // 查找最后一个小于等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if arr[mid] \u003e target { high = mid - 1 } else { if mid == len(arr)-1 || arr[mid+1] \u003e target { return mid } else { low = mid + 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:4","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["go"],"content":"题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:1","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["go"],"content":"解题思路 要求求出根号 x 根号 x 的取值范围一定在[0, x]之间，这个区间内的值是递增有序的，有边界的，可以用下标访问的，二分查找正好满足这三个条件，所以可以使用二分查找 ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:2","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["go"],"content":"实现代码 暴力解法 func mySqrt(x int) int { for i := 0; i \u003c= x; i++ { res := i * i if res == x { return i } else if res \u003e x { return i - 1 } } return -1 } 二分查找法 思路 根号 x 的取值范围一定在[0, x]之间，找到最后一个整数平方之后的值小于或等于x 查找最后一个小于或等于给定值的元素，所以当 res \u003c= x 时，需要确认一下 这个数的后一位的平方大于 x 如果 mid+1的平方小于或等于 x，说明mid肯定不是目的整数，更新low func mySqrt(x int) int { if x == 0 { return 0 } low, high := 0, x for low \u003c= high { mid := low + ((high-low)\u003e\u003e1) res := mid * mid if res \u003e x { high = mid - 1 } else { if (res == x) || (mid + 1)*(mid+1) \u003e x { return mid } low = mid + 1 } } return -1 } ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:3","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["Go"],"content":"什么是二分查找 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，讲待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。 时间复杂度分析 ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"时间复杂度 假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是除以 2，最坏情况下，直到查找被缩小为空才停止。 被查找区间的大小变化： $n, \\frac{n}{2} , \\frac{n}{4}, \\frac{n}{8},….,\\frac{n}{2^{k}}, ….$ 这是一个等比数列。其中 $\\frac{n}{2^{k}}=1$ 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次缩小操作，时间复杂度就是 O(k)。通过 $\\frac{n}{2^{k}}=1$，我们可以求得 $k=\\log2^{n}$,所以时间复杂度就是 O(logn)。 代码实现 最简单的二分查找：就是在有序数组中不存在重复的元素。 实现代码如下： ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"非递归代码实现 func bsearch(arr []int, n int, target int) int { low := 0 height := n - 1 for low \u003c= height { mid := low + (height-low)\u003e\u003e1 if arr[mid] == target { return mid } else if arr[mid] \u003c target { low = mid + 1 } else { height = mid - 1 } } return -1 } ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"递归代码实现 // 二分查找递归实现 func bsearch(arr []int, n int, target int) int { return bsearchInternal(arr, 0, n-1, target) } func bsearchInternal(arr []int, low, high, target int) int { if low \u003e high { return -1 } mid := low + ((high-low)\u003e\u003e1) if arr[mid] == target { return mid } else if arr[mid] \u003c target { return bsearchInternal(arr, mid+1, high, target) } else { return bsearchInternal(arr, low, mid-1, target) } } ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"容易出错的三个地方 1、循环退出条件 注意是 low\u003c=high，而不是 low\u003chigh 2、mid 的取值 mid := (low+high)/2这种写法很容易出问题，如果low和high都很大，两者之和就可能会溢出。改进的方法可以写成这样：mid := low+(high-low)/2，为了优化性能，除以2可以写成位运算，mid := low+((high-low)\u003e\u003e1) 3、low和high的更新 low= mid+1, high=mid-1 二分查找应用场景的局限性 首先，二分查找依赖的是循序表结构，简单点说就是数组 其次，二分查找针对的是有序数据 再此，数据量太小不适合二分查找 最后，数据量太大也不适合二分查找，因为数组结构是需要连续的空间 ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["go"],"content":"题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 我的解答 func twoSum(nums []int, target int) []int { // 创建一个map，因为在map中查找的时间复杂度为O(1) m := make(map[int]int) // 遍历数组，查找差值是否在map中， // 如果在直接返回map的value // 如果不在则把当前值和位置存入map中，以便下次查找 for i := 0; i \u003c len(nums); i++ { another := target - nums[i] if _, ok := m[another]; ok { return []int{m[another], i} } m[nums[i]] = i } return nil } ","date":"2021-01-19","objectID":"/leetcode01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["LeetCode","go"],"title":"LeetCode01_两数之和","uri":"/leetcode01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["hugo"],"content":"转载：https://www.cnblogs.com/xiaowj/p/13934555.html 为了解决为知笔记使用Typora编辑markdown文件图片丢失的问题，我采用了PicGo-Core + Github实现了自定图床的功能。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:0:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"下载PicGo-Core 由于我的电脑有nodejs环境，所以我使用的是npm命令安装picgo, 命令如下： npm install picgo -g 安装完成后，检查命令行输出, 记录下红色框内的路径。 输入命令查看版本，如果有输出则添加成功。 picgo -v ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:1:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"安装github-plus 官方提供的github上传图库不好用，安装一款新的上传插件github-plus, 命令行执行： picgo install github-plus 安装成功后会有提示。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:2:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"Typora图像设置 在Typora中配置图像上传信息。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"设置PicGo的配置信息 如上图所示，分为2个步骤： 上传服务选择PicGo-Core(command line) 打开配置文件，在打开的配置文件，添加相关信息。 { \"picBed\": { \"uploader\": \"githubPlus\", \"current\": \"githubPlus\", \"githubPlus\": { \"branch\": \"master\",// 仓库分支 \"customUrl\": \"\u003chttps://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest\u003e\", // 访问的自定义url \"origin\": \"github\", // 存放的图片类型 \"repo\": \"wlight/cdn-images\", // 存放图片的仓库 \"path\": \"blog-images\",// 存放图片的仓库目录下的文件夹 \"token\": \"\" // 访问github的仓库的token, 不知道怎么设置的自行百度 } }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true // 启用github-plus插件 }, \"picgo-plugin-github-plus\": { \"lastSync\": \"2020-11-05 07:54:47\" } } ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:1","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"测试配置 根据上述配置完毕后我们需要进行测试链接是否成功，在测试之前还要进行如图所示的修改： 上传服务修改为Custom Command 自定义命令 ： picgo upload 点击验证图片上传选项 如果显示验证成功，则表示配置完成。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:2","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"图片上传 将图片拖入Typora中，然后在图片单击右键，图片上传即可。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:4:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"安装文件重命名插件 picgo-plugin-rename-file picgo-plugin-rename-file 插件可以帮我们安装一定的规则将文件进行重命名，具体设置请看github。 输入一下命令安装: picgo install rename-file 安装完成后，打开picgo的配置文件C:\\\\Users\\\\xxx\\\\.picgo\\\\config.json末尾最后一个大括号前添加一下信息即可。 , \"picgo-plugin-rename-file\": { \"format\": \"{y}/{m}/{d}/{hash}-{origin}-{rand:6}\" } ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:5:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"添加水印 *注意：此插件目前会导致文件上传重命名插件不生效* 插件地址: picgo-plugin-watermark ，watermark插件可以帮我们在上传图片的时候添加水印。 安装命令： picgo install watermark 安装成功后，C:\\\\Users\\\\xxx\\\\.picgo\\\\config.json末尾最后一个大括号前添加一下信息即可。 , \"picgo-plugin-watermark\": { // 以下配置信息参考插件地址说明 \"text\": \"jxiaow\", // 水印名称 \"fontSize\": 18, // 水印字体大小 \"position\":\"rm\" // 水印位置 }, **注意：**由于这个插件安装过程中需要下载字体，会导致下载特别慢，尽可能使用代理。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:6:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["笔记"],"content":"引言 今天拉取自己GitHub上的repo，发现特别特别的慢，搜索了各种方法，例如：修改Host文件，感觉明显不靠谱。自己一直在使用代理，感觉还是得通过代理来解决，最后功夫不负有心人，通过了代理的方式解决了这个一直以来的问题。 注：前提要有梯子，我是使用了池大推荐的一个梯子：Ageneo，一直感觉挺好用的， ","date":"2021-01-13","objectID":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/:0:1","tags":["GitHub"],"title":"解决GitHub clone repo太慢的问题","uri":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["笔记"],"content":"解决办法 我的代理客户端使用的是：clash for windows，开始想着切换到全局模式，git 应该就快了，但 clone 依然很慢，搜索后发现，git 命令并不会直接走全局代理，而是走自己默认的配置，修改这个配置的方法如下： git config --global http.proxy \u003chttp://127.0.0.1:7890\u003e git config --global https.proxy \u003chttps://127.0.0.1:7890\u003e 端口号获取的方式如下： Windows中打开”网络和 Internet“→\"代理\"→\"手动设置代理”，查看代理端口号，上面的命令修改为自己的端口号即可。 设置好以后就可以clone了，这次速度上来了，特别快。 PS D:\\\\study\\\\go\\\\hugo\\\\sites\\\\blog\u003e git submodule add \u003chttps://github.com/dillonzq/LoveIt.git\u003e .\\\\themes\\\\LoveIt Cloning into 'D:/study/go/hugo/sites/blog/.\\\\themes\\\\LoveIt'... remote: Enumerating objects: 9952, done. remote: Total 9952 (delta 0), reused 0 (delta 0), pack-reused 9952R Receiving objects: 100% (9952/9952), 36.96 MiB | 1.83 MiB/s, done. Resolving deltas: 100% (4953/4953), done. warning: LF will be replaced by CRLF in .gitmodules. The file will have its original line endings in your working directory ","date":"2021-01-13","objectID":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/:0:2","tags":["GitHub"],"title":"解决GitHub clone repo太慢的问题","uri":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["hugo"],"content":"创建博客所需 repo 假设你在 GitHub 上的用户名是 abcd，那么在 GitHub 上创建下面两个 repo： 一个叫 blog，用于存放 Hugo 博客的原始文件，包括博客配置，文章的 md 文件等。 另一个叫 abcd.github.io，用于存放 Hugo 编译生成的网页文件，访问博客时看到的就是网页文件。 记得在创建第二个 repo 的时候，至少选上 README、.gitignore、LICENSE 三个文件中的一个，这样创建出来的 repo 就不是空的。 如果不这样做，将第二个 repo 添加为第一个 repo 的子模块的操作就会失败，处理起来会很麻烦 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:0:1","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"配置源文件 repo 依次执行以下命令： *# 将 repo clone 至本机 blog 文件夹中* $ git clone \u003chttps://github.com/abcd/blog.git\u003e *# 用 blog 文件夹生成 Hugo 博客的初始内容* $ hugo new site blog --force *# 将博客主题添加为 blog 这个 repo 的子模块# 这样两者互不影响* $ cd blog $ git submodule add \u003chttps://github.com/varkai/hugo-theme-zozo\u003e themes/zozo echo 'theme = \"zozo\"' \u003e\u003e config.toml ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:1:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"本地测试博客效果 在 content\\\\posts 目录下新建几个后缀为 .md 的 Markdown 文件，随便写上一些内容。然后在命令行执行 hugo server，在浏览器中访问 http://localhost:1313，就能够看到博客效果了。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:2:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"配置最终网页 repo *# 将 public 文件夹与 repo abcd.github.io 相关联* $ git submodule add -b main \u003chttps://github.com/abcd/abcd.github.io.git\u003e public 编辑 Hugo 的配置文件 config.toml，将 baseUrl 字段的值设置为 baseUrl = \"\u003chttps://abcd.github.io/\u003e\" 同时在主项目根目录的 static 文件夹中新建文件 CNAME，文件内容为 abcd.github.io。 这样一来，执行 hugo -D 所编译生成的最终网页 repo 中的所有页面及代码，相关的根链接就都被设置为 https://abcd.github.io/，这样可以保证 GitHub Pages 的功能会正常启用。 除此之外，还需要查看该 repo 的设置界面中，GitHub Pages 这一栏的 Source，所选的分支是不是 main，如果是 Master，还需要切换为 main 才行。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:3:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"使用自动发布博客的脚本 ***#!/bin/sh** # If a command fails then the deploy stops*set -e printf \"\\\\033[0;32mDeploying updates to GitHub...\\\\033[0m\\\\n\" *# Build the project.# 使用指定的主题编译博客* hugo -t zozo *# if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e`# Go To Public folder*cd public *# Add changes to git.* git add . *# Commit changes.*msg**=**\"rebuilding site **$(**date**)**\" **if** **[** -n \"$*\" **]**; **then**msg**=**\"$*\" **fi** git commit -m \"$msg\" *# Push source and build repos.# 2020-10-17：注意：现在 GitHub 的主分支已经改名为 main* git push origin main 然后再执行下面的命令，来测试脚本是否可用 *# 首次执行，需为脚本开启对应权限* $ chmod +x deploy.sh *# 调用脚本，发布博客* $ ./deploy.sh \"首次用脚本自动发布博客\" ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:4:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"使用自定义域名 如果不想用 GitHub 的二级域名，而是想用自己的域名，那就需要额外再做一些配置。 假设你购买了域名 blog.com，那么就要在你的域名提供商那里，给该域名添加一条 CNAME 记录，将二级域名 www 的记录值，设置为前面给第二个仓库设置的名称：abcd.github.io。 然后修改 Hugo 配置文件 config.toml 中 baseUrl 字段的值为 www.blog.com，同时修改 static/CNAME 文件的内容为 www.blog.com。 这样一来，当用户访问 www.blog.com 的时候，其实显示的就是 abcd.github.io 中的内容。这样不需要额外找服务器来存放博客文件，省事多了。 对了，GitHub 默认会为 GitHub Pages 启用 HTTPS，你可能还需要为你的域名开启 HTTPS。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"Git 子模块 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:1","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"1.添加子模块 \u003e git submodule add \u003curl\u003e \u003cpath\u003e url 为子模块的路径(本文为博客git地址)， path 为子模块存储的目录路径，执行完需重新提交项目 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:2","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"2.克隆壳工程 重新克隆完壳工程后，子模块并不会一同出现，需要进行初始化 \u003egit submodule init \u003egit submodule update 或者： \u003egit submodule update --init --recursive 子模块更新，当子模块有了新的提交，如何更新本地项目呢？ 首先进入子模块,拉取更新 \u003egit pull 返回项目根目录,重新提交项目 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:3","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"3.删除子模块 处于项目根目录，全部执行完记得重新提交项目 将子模块从版本控制中移除 \u003egit rm --cached 子模块名称 删除子模块目录 \u003erm -rf 子模块目录 删除.gitmodules需要删除子模块信息 \u003evim .gitmodules 删除文件中的子模块信息 \u003evim .git/config 删除模块下的子模块目录 \u003erm -rf .git/module/子模块名称 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:4","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"引用链接 基于hugo快速搭建个人博客 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:5","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"}]