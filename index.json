[{"categories":[],"content":"查询两张表 并且对为空的值做默认值 select u.User_pictureUrl, u.User_phone,u.ID as userId, u.user_nickname, IFNULL(f.userFriend_status,3)as status , IFNULL(f.userFriend_comment,' ')as userFriend_comment, IFNULL(f.userFriend_address,' ')as userFriend_address from tab_userinfo u LEFT JOIN tab_userfriend f ON u.ID=f.userFriend_user_id where u.ID=#{userId} mybatis中插入 \u003cinsert id=\"insertForeach\" parameterType=\"java.util.List\" \u003e insert into user_message ( skip_id,user_id ) values \u003cforeach collection=\"list\" item=\"userMessage\" index=\"index\" separator=\",\"\u003e ( ifnull(#{userMessage.skipId},\"0\"), #{userMessage.userId} ) \u003c/foreach\u003e \u003c/insert\u003e 等同于： \u003cif test=\"userMessage.skipId !=null and userMessage.skipId!=''\"\u003e #{userMessage.skipId}, \u003c/if\u003e \u003cif test=\"userMessage.skipSonId !=null and userMessage.skipSonId!=''\"\u003e #{userMessage.skipSonId}, \u003c/if\u003e \u003cif test=\"userMessage.jumpType !=null and userMessage.jumpType!=''\"\u003e #{userMessage.jumpType}, \u003c/if\u003e \u003cif test=\"userMessage.skipId ==null or userMessage.skipId ==''\"\u003e \"0\", \u003c/if\u003e \u003cif test=\"userMessage.skipSonId ==null or userMessage.skipSonId ==''\"\u003e \"0\", \u003c/if\u003e \u003cif test=\"userMessage.jumpType ==null or userMessage.jumpType ==''\"\u003e 0, \u003c/if\u003e ","date":"2021-07-26","objectID":"/mysql-mybatis%E5%AF%B9%E4%B8%BAnull%E7%9A%84%E5%80%BC%E8%B5%8B%E9%BB%98%E8%AE%A4%E5%80%BCifnull/:0:0","tags":[],"title":"Mysql+mybatis对为null的值赋默认值（ifnull）","uri":"/mysql-mybatis%E5%AF%B9%E4%B8%BAnull%E7%9A%84%E5%80%BC%E8%B5%8B%E9%BB%98%E8%AE%A4%E5%80%BCifnull/"},{"categories":["java"],"content":"Spring之RestTemplate使用小结 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"I. RestTempalate 基本使用 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:0","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么 简单的给出了一下常见的问题如下 普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本篇主要关注在RestTemplate的简单Get/Post请求的使用方式上 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:1","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种 // get 请求 public \u003cT\u003e T getForObject(); public \u003cT\u003e ResponseEntity\u003cT\u003e getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public \u003cT\u003e T postForObject(); public \u003cT\u003e ResponseEntity\u003cT\u003e postForEntity(); // put 请求 public void put(); // pathch public \u003cT\u003e T patchForObject // delete public void delete() // options public Set\u003cHttpMethod\u003e optionsForAllow // exchange public \u003cT\u003e ResponseEntity\u003cT\u003e exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:2","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"2. Get请求 从上面的接口命名上，可以看出可以使用的有两种方式 getForObject 和 getForEntity，那么这两种有什么区别？ 从接口的签名上，可以看出一个是直接返回预期的对象，一个则是将对象包装到 ResponseEntity 封装类中 如果只关心返回结果，那么直接用 GetForObject 即可 如果除了返回的实体内容之外，还需要获取返回的header等信息，则可以使用 getForEntit a. 创建Get接口 为了验证RestTemplate的使用姿势，当然得先提供一个后端的REST服务，这了直接用了我个人的一个古诗词的后端接口，来作为简单的Get测试使用 请求连接： https://story.hhui.top/detail?id=666106231640 返回结果: { \"status\": { \"code\": 200, \"msg\": \"SUCCESS\" }, \"result\": { \"id\": 666106231640, \"title\": \"西塞山二首（今谓之道士矶，即兴国军大冶县\", \"author\": \"王周\", \"content\": \"西塞名山立翠屏，浓岚横入半江青。\\n千寻铁锁无由问，石壁空存道者形。\\n匹妇顽然莫问因，匹夫何去望千春。\\n翻思岵屺传诗什，举世曾无化石人。\", \"explain\": \"\", \"theme\": \"无\", \"dynasty\": \"唐诗\" } } b. getForObject方式 首先看下完整的接口签名 @Nullable public \u003cT\u003e T getForObject(String url, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException ; @Nullable public \u003cT\u003e T getForObject(String url, Class\u003cT\u003e responseType, Map\u003cString, ?\u003e uriVariables) throws RestClientException ; @Nullable public \u003cT\u003e T getForObject(URI url, Class\u003cT\u003e responseType) throws RestClientException; 有三个重载的方法，从接口上也比较容易看出如何使用，其中有点疑惑的则是第一钟，参数应该怎么传了，下面给出上面几种的使用姿势 public class RestTestmplateTest { private RestTemplate restTemplate; @Before public void init() { restTemplate = new RestTemplate(); } @lombok.Data static class InnerRes { private Status status; private Data result; } @lombok.Data static class Status { int code; String msg; } @lombok.Data static class Data { long id; String theme; String title; String dynasty; String explain; String content; String author; } @Test public void testGet() { // 使用方法一，不带参数 String url = \"https://story.hhui.top/detail?id=666106231640\"; InnerRes res = restTemplate.getForObject(url, InnerRes.class); System.out.println(res); // 使用方法一，传参替换 url = \"https://story.hhui.top/detail?id={?}\"; res = restTemplate.getForObject(url, InnerRes.class, \"666106231640\"); System.out.println(res); // 使用方法二，map传参 url = \"https://story.hhui.top/detail?id={id}\"; Map\u003cString, Object\u003e params = new HashMap\u003c\u003e(); params.put(\"id\", 666106231640L); res = restTemplate.getForObject(url, InnerRes.class, params); System.out.println(res); // 使用方法三，URI访问 URI uri = URI.create(\"https://story.hhui.top/detail?id=666106231640\"); res = restTemplate.getForObject(uri, InnerRes.class); System.out.println(res); } } 看上面的testcase，后面两个方法的使用没什么好说的，主要看一下org.springframework.web.client.RestTemplate#getForObject(java.lang.String, java.lang.Class\u003cT\u003e, java.lang.Object...) 的使用姿势 根据实际传参替换url模板中的内容 使用方法一时，模板中使用 {?} 来代表坑位，根据实际的传参顺序来填充 使用方法二时，模板中使用 {xx}, 而这个xx，对应的就是map中的key 上面执行后的截图如下 c. getForEntity方式 既然getForObject有三种使用方法，那么getForEntity理论上也应该有对应的三种方式 public \u003cT\u003e ResponseEntity\u003cT\u003e getForEntity(String url, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException ; public \u003cT\u003e ResponseEntity\u003cT\u003e getForEntity(String url, Class\u003cT\u003e responseType, Map\u003cString, ?\u003e uriVariables) throws RestClientException; public \u003cT\u003e ResponseEntity\u003cT\u003e getForEntity(URI url, Class\u003cT\u003e responseType) throws RestClientException; 因为使用姿势和上面一致，因此只拿一个进行测试 @Test public void testGetForEntity() { String url = \"https://story.hhui.top/detail?id=666106231640\"; ResponseEntity\u003cInnerRes\u003e res = restTemplate.getForEntity(url, InnerRes.class); System.out.println(res); } 对这个，我们主要关注的就是ResponseEntity封装中，多了哪些东西，截图如下 从上面可以看出，多了两个东西 一个返回的http状态码，如200表示请求成功，500服务器错误，404not found等 一个 ResponseHeader ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:3","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"3. Post请求 从上面的接口说明上看，post请求除了有forObject 和 forEntity之外，还多了个forLocation；其次post与get一个明显的区别就是传参的姿势问题，get的参数一般会待在url上；post的则更常见的是通过表单的方式提交 因此接下来关注的重点在于forLocation是什么，以及如何传参 a. post接口mock 首先创建一个简单的提供POST请求的REST服务，基于Spring-boot简单搭建一个，如下 @ResponseBody @RequestMapping(path = \"post\", method = {RequestMethod.GET, RequestMethod.OPTIONS, RequestMethod.POST}) public String post(HttpServletRequest request, @RequestParam(value = \"email\", required = false) String email, @RequestParam(value = \"nick\", required = false) String nick) { Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"code\", \"200\"); map.put(\"result\", \"add \" + email + \" # \" + nick + \" success!\"); return JSON.toJSONString(map); } b. postForObject方法 首先看一下接口签名 public \u003cT\u003e T postForObject(String url, @Nullable Object request, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException ; public \u003cT\u003e T postForObject(String url, @Nullable Object request, Class\u003cT\u003e responseType, Map\u003cString, ?\u003e uriVariables) throws RestClientException; public \u003cT\u003e T postForObject(URI url, @Nullable Object request, Class\u003cT\u003e responseType) throws RestClientException ; 上面的三个方法，看起来和前面并没有太大的区别，只是多了一个request参数，那么具体的使用如何呢？ 下面分别给出使用用例 @Test public void testPost() { String url = \"http://localhost:8080/post\"; String email = \"test@hhui.top\"; String nick = \"一灰灰Blog\"; MultiValueMap\u003cString, String\u003e request = new LinkedMultiValueMap\u003c\u003e(); request.add(\"email\", email); request.add(\"nick\", nick); // 使用方法三 URI uri = URI.create(url); String ans = restTemplate.postForObject(uri, request, String.class); System.out.println(ans); // 使用方法一 ans = restTemplate.postForObject(url, request, String.class); System.out.println(ans); // 使用方法一，但是结合表单参数和uri参数的方式，其中uri参数的填充和get请求一致 request.clear(); request.add(\"email\", email); ans = restTemplate.postForObject(url + \"?nick={?}\", request, String.class, nick); System.out.println(ans); // 使用方法二 Map\u003cString, String\u003e params = new HashMap\u003c\u003e(); params.put(\"nick\", nick); ans = restTemplate.postForObject(url + \"?nick={nick}\", request, String.class, params); System.out.println(ans); } 上面分别给出了三种方法的调用方式，其中post传参区分为两种，一个是uri参数即拼接在url中的，还有一个就是表单参数 uri参数，使用姿势和get请求中一样，填充uri中模板坑位 表单参数，由MultiValueMap封装，同样是kv结构 c. postForEntity 和前面的使用姿势一样，无非是多了一层包装而已，略过不讲 d. postForLocation 这个与前面有点区别，从接口定义上来说，主要是 POST 数据到一个URL，返回新创建资源的URL 同样提供了三个接口，分别如下，需要注意的是返回结果，为URI对象,即网络资源 public URI postForLocation(String url, @Nullable Object request, Object... uriVariables) throws RestClientException ; public URI postForLocation(String url, @Nullable Object request, Map\u003cString, ?\u003e uriVariables) throws RestClientException ; public URI postForLocation(URI url, @Nullable Object request) throws RestClientException ; 那么什么样的接口适合用这种访问姿势呢？ 想一下我们一般登录or注册都是post请求，而这些操作完成之后呢？大部分都是跳转到别的页面去了，这种场景下，就可以使用 postForLocation 了，提交数据，并获取返回的URI，一个测试如下 首先mock一个后端接口 @ResponseBody @RequestMapping(path = \"success\") public String loginSuccess(String email, String nick) { return \"welcome \" + nick; } @RequestMapping(path = \"post\", method = {RequestMethod.GET, RequestMethod.OPTIONS, RequestMethod.POST}) public String post(HttpServletRequest request, @RequestParam(value = \"email\", required = false) String email, @RequestParam(value = \"nick\", required = false) String nick) { return \"redirect:/success?email=\" + email + \"\u0026nick=\" + nick + \"\u0026status=success\"; } 访问的测试用例，基本上和前面的一样，没有什么特别值得一说的 @Test public void testPostLocation() { String url = \"http://localhost:8080/post\"; String email = \"test@hhui.top\"; String nick = \"一灰灰Blog\"; MultiValueMap\u003cString, String\u003e request = new LinkedMultiValueMap\u003c\u003e(); request.add(\"email\", email); request.add(\"nick\", nick); // 使用方法三 URI uri = restTemplate.postForLocation(url, request); System.out.println(uri); } 执行结果如下 获取到的就是302跳转后端url，细心的朋友可能看到上面中文乱码的问题，如何解决呢？ 一个简单的解决方案就是url编码一下 @RequestMapping(path = \"post\", method = {RequestMethod.GET, RequestMethod.OPTIONS, RequestMethod.POST}, produces = \"charset/utf8\") public String post(HttpServletRequest request, @RequestParam(value = \"email\", required = false) String email, @RequestParam(value = \"n","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:4","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"II. 小结 上面目前只给出了Get/Post两种请求方式的基本使用方式，并没有涉及到更高级的如添加请求头，添加证书，设置代理等，高级的使用篇等待下一篇出炉，下面小结一下上面的使用姿势 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:0","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"1. Get请求 get请求中，参数一般都是带在url上，对于参数的填充，有两种方式，思路一致都是根据实际的参数来填充url中的占位符的内容；根据返回结果，也有两种方式，一个是只关心返回对象，另一个则包含了返回headers信心 参数填充 形如 http://story.hhui.top?id={0} 的 url 调用 getForObject(String url, Class\u003cT\u003e responseType, Object... uriVariables) 模板中的0，表示 uriVariables 数组中的第0个， i，则表示第i个 如果没有url参数，也推荐用这个方法，不传uriVariables即可 形如 http://story.hhui.top?id={id} 的 url 调用 getForObject(String url, Class\u003cT\u003e responseType, Map\u003cString, ?\u003e uriVariables) map参数中的key，就是url参数中 {} 中的内容 其实还有一种传参方式，就是path参数，填充方式和上面一样，并没有什么特殊的玩法，上面没有特别列出 返回结果 直接获取返回的数据 getForObject 获取待responseHeader的数据 getForEntity ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:1","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"2. Post请求 post请求的返回也有两种，和上面一样 post请求，参数可以区分为表单提交和url参数，其中url参数和前面的逻辑一致 post表单参数，请包装在 MultiValueMap 中，作为第二个参数 Request 来提交 post的方法，还有一个 postForLocation，返回的是一个URI对象，即适用于返回网络资源的请求方式 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:2","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["java"],"content":"3. 其他 最前面提了多点关于网络请求的常见case，但是上面的介绍，明显只处于基础篇，我们还需要关注的有 如何设置请求头？ 有身份验证的请求，如何携带身份信息？ 代理的设置 文件上传可以怎么做？ post提交json串（即RequestBody) 又可以怎么处理 上面可能还停留在应用篇，对于源码和实现有兴趣的话，问题也就来了 RestTemplaet的实现原理是怎样的 前面url参数的填充逻辑实现是否优雅 返回的对象如何解析 …. 小小的一个工具类，其实东西还挺多的，接下来的小目标，就是针对上面提出的点，逐一进行研究 作者：一灰灰 链接：https://juejin.cn/post/6844903656165212174 来源：掘金 ","date":"2021-06-18","objectID":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:3","tags":["java","springboot"],"title":"RestTemplate使用小结","uri":"/resttemplate%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["git"],"content":"本文转载自：Git各指令的本质，真是通俗易懂啊 (juejin.cn) ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:0:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"前言 作为当前世界上最强大的代码管理工具Git相信大家都很熟悉，但据我所知有很大一批人停留在clone、commit、pull、push...的阶段，是不是对rebase心里没底只敢用merge？碰见版本回退就抓瞎？别问我怎么知道的，问就是：“我曾经就是这样啊～～”。针对这些问题，今天我就将这几年对Git的认知和理解分享出来，尽可能的从本质去讲解Git，帮助你一步一步去了解Git的底层原理，相信读完本篇文章你便可以换种姿态，更加风骚得使用Git各种指令。 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:1:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"目录 基本概念 1.1 Git的优势 1.2 文件状态 1.3 commit 节点 1.4 HEAD 1.5 远程仓库 分支 2.1 什么是分支？ 命令详解 3.1 提交相关 3.2 分支相关 3.3 合并相关 3.4 回退相关 3.5 远程相关 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:2:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1. 基本概念 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1.1 Git的优势 Git是一个分布式代码管理工具，在讨论分布式之前避免不了提及一下什么是中央式代码管理仓库 中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是svn 分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。代表就是Git 那Git相比于svn有什么优势呢？打个比方：“巴拉巴拉写了一大堆代码，突然发现写的有问题，我想回到一个小时之前”，对于这种情况Git的优势就很明显了，因为commit的成本比较小并且本地会保存所有的提交记录，随时随刻可以进行回退。在这并不是说svn的不能完成这种操作，只是Git的回退会显得更加的优雅。Git相比于中央式工具还有很多优点，就不一一列举了，感兴趣的可自行了解。 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:1","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1.2 文件状态 在Git中文件大概分为三种状态：已修改（modified）、已暂存（staged）、已提交（committed） 修改：Git可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到modified区域 暂存：通过add命令将工作目录中修改的文件提交到暂存区，等候被commit 提交：将暂存区文件commit至Git目录中永久保存 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:2","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1.3 commit节点 为了便于表述，本篇文章我会通过节点代称commit提交 在Git中每次提交都会生成一个节点,而每个节点都会有一个哈希值作为唯一标示，多次提交会形成一个线性节点链（不考虑merge的情况），如图1-1 节点上方是通过 SHA1计算的哈希值 C2节点包含C1提交内容,同样C3节点包含C1、C2提交内容 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:3","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1.4 HEAD HEAD是Git中非常重要的一个概念，你可以称它为指针或者引用，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，换句话说就是当前工作目录(也就是你所看到的代码)就是HEAD指向的节点。 还以图1-1举例，如果HEAD指向C2那工作目录对应的就是C2节点。具体如何移动HEAD指向后面会讲到，此处不要纠结。 同时HEAD也可以指向一个分支，间接指向分支所指向的节点 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:4","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"1.5 远程仓库 虽然Git会把代码以及历史保存在本地，但最终还是要提交到服务器上的远程仓库。通过clone命令可以把远程仓库的代码下载到本地，同时也会将提交历史、分支、HEAD等状态一并同步到本地，但这些状态并不会实时更新，需要手动从远程仓库去拉取，至于何时拉、怎么拉后面章节会讲到。 通过远程仓库为中介，你可以和你的同事进行协同开发，开发完新功能后可以申请提交至远程仓库，同时也可以从远程仓库拉取你同事的代码。 注意点 因为你和你的同事都会以远程仓库的代码为基准，所以要时刻保证远程仓库的代码质量，切记不要将未经检验测试的代码提交至远程仓库 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:3:5","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"2. 分支 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:4:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"2.1 什么是分支？ 分支也是Git中相当重要的一个概念，当一个分支指向一个节点时，当前节点的内容即是该分支的内容，它的概念和HEAD非常接近同样也可以视为指针或引用，不同的是分支可以存在多个，而HEAD只有一个。通常会根据功能或版本建立不同的分支 那分支有什么用呢？ 举个例子：你们的 App 经历了千辛万苦终于发布了v1.0版本，由于需求紧急v1.0上线之后便马不停蹄的开始v1.1，正当你开发的兴起时，QA同学说用户反馈了一些bug，需要修复然后重新发版，修复v1.0肯定要基于v1.0的代码，可是你已经开发了一部分v1.1了，此时怎么搞？ 面对上面的问题通过引入分支概念便可优雅的解决，如图2-1 先看左边示意图，假设C2节点既是v1.0版本代码，上线后在C2的基础上新建一个分支ft-1.0 再看右边示意图，在v1.0上线后可在master分支开发v1.1内容，收到QA同学反馈后提交v1.1代码生成节点C3，随后切换到ft-1.0分支做bug修复，修复完成后提交代码生成节点C4，然后再切换到master分支并合并ft-1.0分支，到此我们就解决了上面提出的问题 除此之外利用分支还可以做很多事情，比如现在有一个需求不确定要不要上线，但是得先做，此时可以单独创建一个分支开发该功能，等到啥时候需要上线直接合并到主分支即可。分支适用的场景很多就不一一列举了。 注意点 当在某个节点创建一个分支后，并不会把该节点对应的代码复制一份出来，只是将新分支指向该节点，因此可以很大程度减少空间上的开销。一定要记着不管是HEAD还是分支它们都只是引用而已，量级非常轻 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:4:1","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3. 命令详解 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3.1 提交相关 前面我们提到过，想要对代码进行提交必须得先加入到暂存区，Git中是通过命令 add 实现 添加某个文件到暂存区： git add 文件路径 复制代码 添加所有文件到暂存区： git add . 复制代码 同时Git也提供了撤销工作区和暂存区命令 撤销工作区改动： git checkout -- 文件名 复制代码 清空暂存区： git reset HEAD 文件名 复制代码 提交： 将改动文件加入到暂存区后就可以进行提交了，提交后会生成一个新的提交节点，具体命令如下： git commit -m \"该节点的描述信息\" 复制代码 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:1","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3.2 分支相关 创建分支 创建一个分支后该分支会与HEAD指向同一节点，说通俗点就是HEAD指向哪创建的新分支就指向哪，命令如下： git branch 分支名 复制代码 切换分支 当切换分支后，默认情况下HEAD会指向当前分支，即HEAD间接指向当前分支指向的节点 git checkout 分支名 复制代码 同时也可以创建一个分支后立即切换，命令如下： git checkout -b 分支名 复制代码 删除分支 为了保证仓库分支的简洁，当某个分支完成了它的使命后应该被删除。比如前面所说的单独开一个分支完成某个功能，当这个功能被合并到主分支后应该将这个分支及时删除。 删除命令如下： git branch -d 分支名 复制代码 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:2","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3.3 合并相关 关于合并的命令是最难掌握同时也是最重要的。我们常用的合并命令大概有三个merge、rebase、cherry-pick merge merge是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支。具体命令如下： git merge 分支名/节点哈希值 复制代码 如果需要合并的分支完全领先于当前分支，如图3-1所示 由于分支ft-1完全领先分支ft-2即ft-1完全包含ft-2，所以ft-2执行了“git merge ft-1”后会触发fast forward(快速合并)，此时两个分支指向同一节点，这是最理想的状态。但是实际开发中我们往往碰到是是下面这种情况：如图3-2(左) 这种情况就不能直接合了，当ft-2执行了“git merge ft-1”后Git会将节点C3、C4合并随后生成一个新节点C5，最后将ft-2指向C5 如图3-2(右) 注意点： 如果C3、C4同时修改了同一个文件中的同一句代码，这个时候合并会出错，因为Git不知道该以哪个节点为标准，所以这个时候需要我们自己手动合并代码 rebase rebase也是一种合并指令，命令行如下： git rebase 分支名/节点哈希值 复制代码 与merge不同的是rebase合并看起来不会产生新的节点(实际上是会产生的，只是做了一次复制)，而是将需要合并的节点直接累加 如图3-3 当左边示意图的ft-1.0执行了git rebase master后会将C4节点复制一份到C3后面，也就是C4'，C4与C4'相对应，但是哈希值却不一样。 rebase相比于merge提交历史更加线性、干净，使并行的开发流程看起来像串行，更符合我们的直觉。既然rebase这么好用是不是可以抛弃merge了？其实也不是了，下面我罗列一些merge和rebase的优缺点： merge优缺点： 优点：每个节点都是严格按照时间排列。当合并发生冲突时，只需要解决两个分支所指向的节点的冲突即可 缺点：合并两个分支时大概率会生成新的节点并分叉，久而久之提交历史会变成一团乱麻 rebase优缺点： 优点：会使提交历史看起来更加线性、干净 缺点：虽然提交看起来像是线性的，但并不是真正的按时间排序，比如图3-3中，不管C4早于或者晚于C3提交它最终都会放在C3后面。并且当合并发生冲突时，理论上来讲有几个节点rebase到目标分支就可能处理几次冲突 对于网络上一些只用rebase的观点，作者表示不太认同，如果不同分支的合并使用rebase可能需要重复解决冲突，这样就得不偿失了。但如果是本地推到远程并对应的是同一条分支可以优先考虑rebase。所以我的观点是 根据不同场景合理搭配使用merge和rebase，如果觉得都行那优先使用rebase cherry-pick cherry-pick的合并不同于merge和rebase，它可以选择某几个节点进行合并，如图3-4 命令行： git cherry-pick 节点哈希值 复制代码 假设当前分支是master，执行了git cherry-pick C3(哈希值)，C4(哈希值)命令后会直接将C3、C4节点抓过来放在后面，对应C3'和C4' ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:3","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3.4 回退相关 分离HEAD 在默认情况下HEAD是指向分支的，但也可以将HEAD从分支上取下来直接指向某个节点，此过程就是分离HEAD，具体命令如下： git checkout 节点哈希值 //也可以直接脱离分支指向当前节点 git checkout --detach 复制代码 由于哈希值是一串很长很长的乱码，在实际操作中使用哈希值分离HEAD很麻烦，所以Git也提供了HEAD基于某一特殊位置(分支/HEAD)直接指向前一个或前N个节点的命令，也即相对引用，如下： //HEAD分离并指向前一个节点 git checkout 分支名/HEAD^ 复制代码 //HEAD分离并指向前N个节点 git checkout 分支名～N 复制代码 将HEAD分离出来指向节点有什么用呢？举个例子：如果开发过程发现之前的提交有问题，此时可以将HEAD指向对应的节点，修改完毕后再提交，此时你肯定不希望再生成一个新的节点，而你只需在提交时加上--amend即可，具体命令如下： git commit --amend 复制代码 回退 回退场景在平时开发中还是比较常见的，比如你巴拉巴拉写了一大堆代码然后提交，后面发现写的有问题，于是你想将代码回到前一个提交，这种场景可以通过reset解决，具体命令如下： //回退N个提交 git reset HEAD~N 复制代码 reset和相对引用很像，区别是reset会使分支和HEAD一并回退。 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:4","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"3.5 远程相关 当我们接触一个新项目时，第一件事情肯定是要把它的代码拿下来，在Git中可以通过clone从远程仓库复制一份代码到本地，具体命令如下： git clone 仓库地址 复制代码 前面的章节我也有提到过，clone不仅仅是复制代码，它还会把远程仓库的引用(分支/HEAD)一并取下保存在本地，如图3-5所示： 其中origin/master和origin/ft-1为远程仓库的分支，而远程的这些引用状态是不会实时更新到本地的，比如远程仓库origin/master分支增加了一次提交，此时本地是感知不到的，所以本地的origin/master分支依旧指向C4节点。我们可以通过fetch命令来手动更新远程仓库状态 小提示： 并不是存在服务器上的才能称作是远程仓库，你也可以clone本地仓库作为远程，当然实际开发中我们不可能把本地仓库当作公有仓库，说这个只是单纯的帮助你更清晰的理解分布式 fetch 说的通俗一点，fetch命令就是一次下载操作，它会将远程新增加的节点以及引用(分支/HEAD)的状态下载到本地，具体命令如下： git fetch 远程仓库地址/分支名 复制代码 pull pull命令可以从远程仓库的某个引用拉取代码，具体命令如下： git pull 远程分支名 复制代码 其实pull的本质就是fetch+merge，首先更新远程仓库所有状态到本地，随后再进行合并。合并完成后本地分支会指向最新节点 另外pull命令也可以通过rebase进行合并，具体命令如下： git pull --rebase 远程分支名 复制代码 push push命令可以将本地提交推送至远程，具体命令如下： git push 远程分支名 复制代码 如果直接push可能会失败，因为可能存在冲突，所以在push之前往往会先pull一下，如果存在冲突本地解决。push成功后本地的远程分支引用会更新，与本地分支指向同一节点 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:5:5","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":["git"],"content":"综上所述 不管是HEAD还是分支，它们都只是引用而已，引用+节点是 Git 构成分布式的关键 merge相比于rebase有更明确的时间历史，而rebase会使提交更加线性应当优先使用 通过移动HEAD可以查看每个提交对应的代码 clone或fetch都会将远程仓库的所有提交、引用保存在本地一份 pull的本质其实就是fetch+merge，也可以加入--rebase通过rebase方式合并 ","date":"2021-05-17","objectID":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/:6:0","tags":["git","github"],"title":"Git各指令的本质真是通俗易懂啊","uri":"/git%E5%90%84%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%9C%9F%E6%98%AF%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%95%8A/"},{"categories":[],"content":"Golang/PHP bug 开发工程师 跑步爱好者 ","date":"2021-05-17","objectID":"/about/:0:0","tags":[],"title":"About","uri":"/about/"},{"categories":["go"],"content":"开发环境 golang 1.16 mysql 5.7 redis etcd (多服务时使用，服务发现) go-zore 框架 官方文档 ","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:1","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"项目开发 创建数据库和数据表 框架初始化 目录拆分 csp // 工程名称 ├── common //通用库 │ ├── errorx │ │ ├── base_error.go // 基础错误处理 │ │ └── error_handler.go // 错误处理 │ └── utils │ └── tools.go ├── go.mod // mod文件 ├── go.sum └── service // 服务存放目录 ├── material │ ├── api │ ├── model │ └── rpc └── order // ├── api // // HTTP访问服务，业务需求实现 │ ├── cmd │ │ ├── etc // 配置文件 │ │ │ └── order-api.yaml │ │ ├── internal │ │ │ ├── config │ │ │ │ └── config.go // 配置声明type │ │ │ ├── handler // 路由及handler转发 │ │ │ │ ├── routes.go │ │ │ │ └── v1 │ │ │ │ ├── create_order_handler.go │ │ │ │ ├── del_orders_handler.go │ │ │ │ ├── get_orders_detail_handler.go │ │ │ │ ├── get_orders_handler.go │ │ │ │ └── update_orders_handler.go │ │ │ ├── logic // 业务逻辑 │ │ │ │ └── v1 │ │ │ │ ├── create_order_logic.go │ │ │ │ ├── del_orders_logic.go │ │ │ │ ├── get_orders_detail_logic.go │ │ │ │ ├── get_orders_logic.go │ │ │ │ └── update_orders_logic.go │ │ │ ├── middleware // 中间件文件 │ │ │ │ └── checkauth_middleware.go │ │ │ ├── svc // logic所依赖的资源池 │ │ │ │ └── service_context.go │ │ │ └── types // request、response的struct，根据api自动生成，不建议编辑 │ │ │ └── types.go │ │ └── order.go // main函数入口 │ └── order.api // api描述文件 ├── model // model层，直接操作数据库，服务访问持久化数据层的桥梁 │ ├── order_datas_model.go │ ├── order_details_model.go │ └── vars.go └── rpc // rpc服务，给其他子系统提供基础数据访问 model 生成 修改 goctl 生成模板 goctl 只能默认用户在建表时会创建createTime、updateTime字段(忽略大小写、下划线命名风格)且默认值均为CURRENT_TIMESTAMP，而updateTime支持ON UPDATE CURRENT_TIMESTAMP，对于这两个字段生成insert、update时会被移除，不在赋值范畴内，当然，如果你不需要这两个字段那也无大碍。但是我们数据库表里使用的是created_at 和 updated_at，所以我们要修改goctl的生成模板。 查找goctl的源代码的位置 $GOPATH/pkg/mod/github.com/tal-tech/go-zero@$VERSION/tools/goctl 查找 createTime，然后替换成 CreatedAt 和 UpdatedAt，修改以下文件 : $GOPATH/pkg/mod/github.com/tal-tech/go-zero@v1.1.7/tools/goctl/model/sql/template/vars.go $GOPATH/pkg/mod/github.com/tal-tech/go-zero@v1.1.7/tools/goctl/model/sql/gen/update.go $GOPATH/pkg/mod/github.com/tal-tech/go-zero@v1.1.7/tools/goctl/model/sql/gen/insert.go $GOPATH/pkg/mod/github.com/tal-tech/go-zero@v1.1.7/tools/goctl/model/sql/parser/parser.go 重新编译成运行工具： cd $GOPATH/pkg/mod/github.com/tal-tech/go-zero@v1.1.7/tools/goctl/ go build mv goctl $GOPATH/bin/ Model 生成方式有以下两种方式： 切换到model文件夹中： cd csp/service/order/model 1、ddl 生成 goctl model mysql ddl -src user.sql -dir . -c 2、datacource 生成 goctl model mysql datasource -url=\"$username:$password@tcp($host)\" -table=\"$tablename\" -c -dir . -style go_zero 格式化符有go,zero组成，如常见的三种格式化风格你可以这样编写： lower: gozero camel: goZero snake: go_zero 注意事项 -c 生成带缓存，目前仅支持 redis 缓存，如果选择带缓存模式，即生成的FindOne(ByXxx)\u0026Delete代码会生成带缓存逻辑的代码，目前仅支持单索引字段（除全文索引外），对于联合索引我们默认认为不需要带缓存，且不属于通用型代码，因此没有放在代码生成行列，如example中user表中的id、name、mobile字段均属于单字段索引。 model事务（TODO：只能在单个model里写事务，感觉很难受啊，暂时没有找到跨model的办法） var insertsql = `insert into User(uid, username, mobilephone) values (?, ?, ?)` err := usermodel.conn.Transact(func(session sqlx.Session) error { stmt, err := session.Prepare(insertsql) if err != nil { return err } defer stmt.Close() // 返回任何错误都会回滚事务 if _, err := stmt.Exec(uid, username, mobilephone); err != nil { logx.Errorf(\"insert userinfo stmt exec: %s\", err) return err } // 还可以继续执行 insert/update/delete 相关操作 return nil }) 事务 中的操作都包装在一个函数 func(session sqlx.Session) error {} 中即可，如果事务中的操作返回任何错误， Transact() 都会自动回滚事务。 api 文件编写 生成 api 文件： cd csp/service/order/api goctl api -o data.api 编写 api 文件，api语法介绍 api 文件生成 api 服务 cd csp/service/data/api // -style 编程代码文件风格，有三种风格，也就是有三种值：gozero(全小写，默认)；goZero/Gozero（驼峰）；go_zero（下划线） goctl api go -api data.api -dir . -style go_zero ","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:2","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"初始化配置 添加 Mysql 和 Redis 配置 vim csp/service/order/api/cmd/internal/config/config.go package config import ( \"github.com/tal-tech/go-zero/core/stores/cache\" \"github.com/tal-tech/go-zero/rest\" ) type Config struct { rest.RestConf Mysql struct{ DataSource string } CacheRedis cache.CacheConf } 完善 yaml 配置 vim csp/service/order/api/cmd/etc/data-api.yaml Name:data-apiHost:0.0.0.0Port:8888Mysql:DataSource:root:123456@tcp(127.0.0.1:3306)/ostar?charset=utf8mb4\u0026parseTime=true\u0026loc=Asia%2FShanghaiCacheRedis:- Host:127.0.0.1:6379Type:node 完善服务依赖 vim csp/service/order/api/cmd/internal/svc/service_context.go package svc import ( \"csp/service/order/api/cmd/internal/config\" \"csp/service/order/api/cmd/internal/middleware\" \"csp/service/order/model\" \"github.com/tal-tech/go-zero/core/stores/sqlx\" \"github.com/tal-tech/go-zero/rest\" ) type ServiceContext struct { Config config.Config CheckAuth rest.Middleware OrderDatasModel model.OrderDatasModel OrderDetailsModel model.OrderDetailsModel } func NewServiceContext(c config.Config) *ServiceContext { conn := sqlx.NewMysql(c.Mysql.DataSource) return \u0026ServiceContext{ Config: c, CheckAuth: middleware.NewCheckAuthMiddleware().Handle, OrderDatasModel: model.NewOrderDatasModel(conn, c.CacheRedis), OrderDetailsModel: model.NewOrderDetailsModel(conn, c.CacheRedis), } } 错误处理 自定义错误 全局错误处理 首先在common中添加一个全局错误处理error_handler.go文件 mkdir -p common/errorx touch error_handler.go package errorx import ( \"github.com/tal-tech/go-zero/core/jsonx\" \"net/http\" ) // ErrorHandler 处理自定义错误 func ErrorHandler(err error) (int, interface{}) { switch e := err.(type) { case *CodeError: return e.statusCode, e.Data() default: return http.StatusInternalServerError, CodeErrorResponse{ Code: defaultCode, Message: err.Error(), } } } // NotFoundHandler 处理 404 错误 func NotFoundHandler() http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusNotFound) w.Header().Set(\"Content-Type\", \"text/json; charset=utf-8\") msg, _ := jsonx.Marshal(CodeErrorResponse{Code: http.StatusNotFound, Message: \"not found\"}) w.Write(msg) }) } 基础错误文件 touch base_error.go package errorx import ( \"net/http\" ) const ( defaultCode = 000 // OrdersModule 数据中心功能模块(编号区间 301 ~ 350) OrdersModule = 301 + iota // 订单模块编号 MaterialsModule ) var ( //ErrorDataNotFound = errors.New(\"data not found\") //ErrorUserNotFound = errors.New(\"用户不存在\") //ErrorNoRequiredParameters = errors.New(\"必要参数不能为空\") //ErrorUserOperation = errors.New(\"用户正在操作中，请稍后重试\") //ErrorServer = NewCodeError(\"系统错误，请联系管理员\") //ErrorMysqlOperation = NewCodeError(350000, \"数据库操作错误\") ) /* HTTP Status状态码\u0008要求与实际的状态码一致 code：6位（前3位为功能模块编号(moduleCode)，后3位为业务错误编号(bizCode)） message：返回成功或者失败或者异常信息 data：返回的数据信息（使用小驼峰命名法作为属性标识符） */ type CodeError struct { statusCode int // http status code moduleCode int // 模块号码 bizCode int // 业务错误号码 message string // 信息 } type CodeErrorResponse struct { Code int `json:\"code\"` Message string `json:\"message\"` } func NewCodeError(httpStatusCode, moduleCode, bizCode int, message string) error { return \u0026CodeError{statusCode: httpStatusCode,moduleCode: moduleCode, bizCode: bizCode, message: message} } // NewDefaultError TODO 默认错误 func NewDefaultError(message string) error { return NewCodeError(http.StatusInternalServerError, http.StatusInternalServerError * 1000, defaultCode, message) } // NotFindDataError 未查找到数据返回错误 func NotFindDataError(moduleCode, bizCode int,message string) error { return NewCodeError(http.StatusNotFound, moduleCode, bizCode, message) } func (e *CodeError) Error() string { return e.message } func (e *CodeError) Data() *CodeErrorResponse { return \u0026CodeErrorResponse{ Code: e.moduleCode * 1000 + e.bizCode, Message: e.message, } } 开启自定义错误 vim service/user/cmd/api/user.go package main import ( \"csp/common/errorx\" \"flag\" \"fmt\" \"github.com/tal-tech/go-zero/rest/httpx\" \"csp/service/data/cmd/api/internal/config\" \"csp/service/data/cmd/api/internal/handler\" \"csp/service/data/cmd/api/internal/svc\" \"github.com/tal-tech/go-zero/core/conf\" \"github.com/tal-tec","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:3","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"编写业务逻辑 业务逻辑代码都在 service/order/api/cmd/internal/logic/ vim service/order/api/cmd/internal/logic/orders/create_orderLogic.go ","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:4","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"运行项目 直接在项目服务目录下运行 go run order.go -f etc/order-api.yaml ","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:5","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"docker 运行 生成 Dockerfile 在 api 业务目录下生成 Dockerfile 切换到服务目录下 cd /csp/service/order/api/cmd 生成 Dokcerfile goctl docker -go order.go 修改 Dockerfile 文件，适合项目运行 FROMgolang:alpine AS builder LABEL stage=gobuilder ENV CGO_ENABLED 0ENV GOOS linuxENV GOPROXY https://goproxy.cn,direct WORKDIR/build/zero ADD go.mod .ADD go.sum .RUN go mod downloadCOPY . .# 修改此路径，因为要复制 go.mod go.sum，所以要在go.mod 所在目录下运行 docker build 构建镜像 ，# 或者修改上面的复制go.mod 文件的地址也可以 COPY service/order/api/cmd/etc /app/etcRUN go build -ldflags=\"-s -w\" -o /app/order service/order/api/cmd/order.go FROMalpine RUN apk update --no-cache \u0026\u0026 apk add --no-cache ca-certificates tzdataENV TZ Asia/Shanghai WORKDIR/appCOPY --from=builder /app/order /app/orderCOPY --from=builder /app/etc /app/etc EXPOSE8888 CMD [\"./order\", \"-f\", \"etc/order-api.yaml\"] 构建镜像 在 go.mod 所在的目录下构建镜像 cd ostar/csp docker build -t order:v1 -f service/order/api/cmd/Dockerfile . 查看生成的镜像 docker image ls 启动服务 docker run --rm -it -p 8888:8888 order:v1 –rm ：停止后删除容器 –i ：以交互模式运行容器，通常与 -t 同时使用； –t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； 测试服务 curl -i http://localhost:8888/order/1 返回数据，成功 ","date":"2021-05-12","objectID":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/:0:6","tags":["go"],"title":"Go Zore开发文档","uri":"/go-zore%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"categories":["go"],"content":"开发环境 golang v1.15.1 go module 开启 go env GO111MODULE on protoc v3.14 https://github.com/protocolbuffers/protobuf/releases protoc-gen-go 1.3.2 $ go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2 etcd redis mysql ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"文档 简介 · go-zero使用文档 (zeromicro.github.io) 最简单的 Go Dockerfile 编写姿势，没有之一！ · GoCN社区 从代码到部署微服务实战（一） ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"项目开发流程 目录拆分 model生成 api文件编写 业务编码 jwt鉴权 中间件使用 rpc文件编写 错误处理 ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"开发规范 编码规范 import 单行 import 不建议用圆括号包括 按照 官方包空行 当前工程包 空行 第三方依赖包 import ( \"context\" \"string\" \"greet/user/internal/config\" \"google.golang.org/grpc\" ) 函数返回 对象避免非指针返回 遵循有正常值返回则一定无 error，有 error 则一定无正常值返回的原则 错误处理 有error必须处理，如果不能处理就必须抛出 避免下划线(_)忽略 error ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"构建docker运行 docker build -t user:v1 -f service/user/cmd/api/Dockerfile . 删除原本的有问题的镜像，-f 是强制删除及其关联状态 若不执行 -f，你需要执行 docker ps -a 查到所关联的容器，将其 rm 解除两者依赖关系 docker run --rm -it -p 8888:8888 user:v1 ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"注意事项 nohup ./etcd \u003e/tmp/etcd.log 2\u003e\u00261 \u0026 # 日志文件输出到/tmp/etcd.log目录 ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["go"],"content":"git Go Modules 入门教程 | Go 技术论坛 (learnku.com) 为了标识身份，建议先完成git全局配置 git config --global user.name \"username\" git config --global user.email \"user@mail.com\" 方式1：克隆仓库 git clone git@codeup.aliyun.com:5f61bcb1df9df74e36b01a89/testmod.git cd testmod touch README.md git add README.md git commit -m \"add README\" git push -u origin master 方式2：已有文件夹或仓库 cd existing_folder git init git remote add origin git@codeup.aliyun.com:5f61bcb1df9df74e36b01a89/testmod.git git add . git commit git push -u origin master 方式3：导入代码库 git clone --bare https://git.example.com/your/project.git your_path cd your_path git remote set-url origin git@codeup.aliyun.com:5f61bcb1df9df74e36b01a89/testmod.git git push --mirror ","date":"2021-03-23","objectID":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["go"],"title":"Go Zore简明教程","uri":"/go-zore%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["java"],"content":"Java 面向对象的语言，面向对象编程OOP(Object-Oriented Programming) ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:0","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"基础 class和instance是模板和实例的关系； 定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例； class定义的field，在每个instance都会拥有各自的field，且互不干扰； 通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance； 访问实例字段的方法是变量名.字段名； 指向instance的变量都是引用变量； ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:1","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"方法 定义方法 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 返回类型如果为void，可以省略return 修饰符 private：不允许外部调用，只有类内部调用 public：公开的，都可以调用 this 始终指向当前实例，如果没有命名冲突，可以省略this,如果局部变量和字段重名，那么局部变量优先级更高，所以必须加this 方法参数 方法可以包含0个或任意个参数。方法参数用于 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:2","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"构造方法 构造方法的名称就是类名，构造方法的参数没有限制，在方法内部，也可以便谢任意语句。但是构造方法没有返回值（也没有void），调用构造方法，必须使用new操作符。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:3","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"方法重载 在一个类中，我们可以定义多个方法，如果有一系列方法，他们的功能都是类似的，只有参数不同，那么，可以把这一组方法做成同名方法。就是重载（Overload） 方法重载的返回值类型通常都是相同的 方法重载的目的是：功能类似的方法使用同一个名字，更容易记住，调用起来更简单。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:4","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"继承 使用extends来继承， 子类自动获得父类的所有字段，严禁定义与父类重名的字段 继承树 所有的类如果没有父类，都是继承自Object类 一个类有且仅有一个父类，单继承 Protected 子类无法访问父类的private字段或者private方法 为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问。 protected关键字可以把字段和方法访问权限控制在继承树内部。 super 子类引用父类的字段时，可以用super.fieldName。等同于this.name或者name。 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便编译器定位到父类的一个合适的构造方法。 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 阻止继承 final不允许继承 向上/向下转型 向上转型：把一个子类实例强制转成父类实例，是安全的，因为子类拥有父类所有的功能 向下转型：把一个父类实例强制转为子类实例，需要使用instanceof来判断一个实例是不是某个类型。（Java14使用之后直接转换成对应的类型） 继承和组合 Student是Person的一种，它们是is关系，而Student并不是Book，Student和Book的关系是has关系。 拥有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例 class Student extends Person { protected Book book; protected int score; } ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:5","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"多态 在继承关系中，子类如果定义了一个父类方法签名完全相同的方法，被称为覆写（override） 如果方法签名不同，就是Overload，Overload方法就是一个新的方法。 如果方法签名相同，返回值也相同，就是Override 注意：方法名相同，方法参数相同，但返回值不同，也是不同的方法。在Java中，出现这种情况，编译器会报错。 class Person { public void run(){} } class Student extends Person { // 加上@Override 可以让编译器帮助检查是否进行了正确的覆写 @Override public void run(){} } 多态就是，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： Person p = new Student(); p.run(); // 无法确定运行时究竟调用哪个run()方法 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/:0:6","tags":["java"],"title":"Java笔记_面向对象基础","uri":"/java%E7%AC%94%E8%AE%B0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"categories":["java"],"content":"遍历 for循环遍历，可以得到数组的索引 for (int i = 0; i \u003c ns.length; i++) { } for each 循环遍历，直接拿到数组元素的值，无法拿到索引 for (int n : ns) { } 打印数组内容 直接打印数组变量，得到是数组在JVM中的引用地址 所以使用for each打印 或者使用Java标准库Arrays.toString()，快速打印数组的内容； import java.util.Arrays; public class Main { public static void main(String[] args) { int[] ns = {1,2,3,4,5}; System.out.println(Arrays.toString(ns)); // [1, 1, 2, 3, 5, 8] } } ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:1","tags":["java"],"title":"Java笔记_数组操作","uri":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["java"],"content":"数组排序 冒泡排序 import java.util.Arrays; public class Main { public static void main(String[] args) { int[] ns = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36}; System.out.println(\"排序前：\" + Arrays.toString(ns)); for (int i = 0; i \u003c ns.length; i ++) { for (int j = ns.length - 1; j \u003e i; j --) { if(ns[j-1] \u003e ns[j]) { int temp = ns[j]; ns[j] = ns[j-1]; ns[j-1] = temp; } } } System.out.println(\"排序后：\"+ Arrays.toString(ns)); } } Java 标准库内置排序功能，Arrays.sort() ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:2","tags":["java"],"title":"Java笔记_数组操作","uri":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["java"],"content":"多维数组 二维数组就是数组的数组，三维数组就是二维数组的数组； 多维数组的每个元素长度都可以不同； 打印多维数组可以使用Arrays.deepToString()； 最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col] ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:3","tags":["java"],"title":"Java笔记_数组操作","uri":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["java"],"content":"if判断 基本语法 if(条件) { // 条件满足时执行 } else if { // 另一个条件满足时执行 } else { // 条件不满足时执行 } 判断相等 整数相等可以直接使用== 浮点数因为无法精确表示，不能直接使用==，利用差值小于某个临界值来判断 引用类型判断相等 ==是判断是否指向同一个对象 判断内容相同使用equals()方法 public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 == s2) { // false System.out.println(\"s1 equals s2\"); } else (s1.equals(s2)) { // true System.out.println(\"s1 equals s2\"); } } } 执行语句s1.equals(s2)时，如果变量s1 为null，会报NullPointerException 要避免NullPointerException错误，可以利用短路运算符\u0026\u0026 s1 != null \u0026\u0026 s1.equals(\"hello\") ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:1","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"switch多重选择 switch语句根据switch(表达式)计算的结果，跳转到匹配的case结果，然后执行后续语句，直到遇到break结束执行。 public class Main { public static void main(String[] args) { int option = 1; switch(option) { case 1: System.out.println(\"Selected 1\"); break; case 2: System.out.println(\"selected 2\"); break; defautl: System.out.println(\"Not selected\"); break; } } } switch也可以匹配字符串，字符串匹配时，是比较“内容相等”。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:2","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"while循环 基本用法 while (条件表达式) { 循环语句 } // 继续执行后续代码 多站在内存的方向想问题 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:3","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"do while 循环 先执行一次循环，然后再判断条件，条件满足继续执行，不满足，退出 do { 执行循环语句 } while (条件表达式) ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:4","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"for 循环 先初始化计数器，在每次循环前检测循环条件，在每次循环后更新计数器。 for (int i = 1; i \u003c= 100; i++) { // 循环语句 } public class Main { public static void main(String[] args) { int ns = {1,4,9,16,25}; int sum = 0; for (int i = 0; i \u003c ns.length; i++) { sum = sum + ns[i]; } System.out.println(sum); } } 灵活使用for循环 缺少初始化语句、循环条件和每次循环更新语句 // 不设置结束条件 for(int i = 0; ; i++) { } // 不设置结束条件和更新语句 for (int i = 0; ; ) { } // 都不设置 for ( ; ; ) { } 通常不推荐 for each 循环 用来遍历数组 public class Main { public static void main(String[] args) { int[] ns = {1,3,5,6,7,12}; for (int n : ns) { System.out.println(n); } } } n不再是计数器，而是直接对应到数组中的每个元素，但是for each无法指定遍历顺序，也无法获取数组的索引。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:5","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"break 和 continue break 在循环过程中，可以使用break语句跳出当前循环。 continue continue提前结束本次循环，直接继续执行下次循环。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:0:6","tags":["java"],"title":"Java笔记_流程控制","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["java"],"content":"输出 System.out.println：输出并换行 System.out.print：输出不换行 格式话输出 System.out.printf：通过占位符%?，可以把后面得参数格式化成指定格式 double d = 3.1516; System.out.printf(\"%.2f\\n\", d); // 显示两位小数3,14 占位符，把各种数据类型格式化成指定得字符串 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 由于%表示占位符，因此两个%% 表示一个%字符本身 详细格式化参数参考JDK文档[java.util.Formatter](Formatter (Java SE 11 \u0026 JDK 11 ) (oracle.com)) 输入 从控制台读取 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/:0:0","tags":["java"],"title":"Java笔记_输入和输出","uri":"/java%E7%AC%94%E8%AE%B0_%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/"},{"categories":["java"],"content":"数组是同一数据类型的集合，定义一个数组类型的变量，使用数组类型类型[]，例如，int[]。数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组，整数数组。 特点 数组所有元素初始化为默认值，整型都是0，浮点型都是0.0，布尔型是false 数组一旦创建后，大小就不可改变。 使用索引来访问数组中的某个元素，索引从0开始 修改数组中的元素，使用赋值语句 获取数组大小数组变量.length 数组是引用类型的，如果索引越界，运行时将报错 public class Main { public static void main(String[] args) { // 创建一个数组 int[] ns = new int[5]; // 赋值 ns[0] = 1; // 访问 System.out.println(ns[0]); // 1 // 定义数组时直接指定初始化的元素，不必写出数组大小，由编译器自动推算 int[] ns1 = new int[]{1,2,3,4,5,6}; // 进一步简写 int[] ns2 = {5,4,3,21,1}; } } 字符串数组 因为字符串也是引用的，所以更改数组的值时，不是更改了字符串的值，而是在新的内存上重新申请了一个字符串，引用到这个新的数组。 ","date":"2021-03-11","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/:0:0","tags":["java"],"title":"Java笔记_数组类型","uri":"/java%E7%AC%94%E8%AE%B0_%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/"},{"categories":["java"],"content":"浮点数只能进行加减乘除运算 ","date":"2021-03-10","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/:0:0","tags":["java"],"title":"Java笔记_浮点数运算","uri":"/java%E7%AC%94%E8%AE%B0_%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"},{"categories":["java"],"content":"整数运算 基本运算 遵循四则运算法则 整数的数值表示时精确的，整数运算也永远是精确的，即使是除法也是精确的（两数相除只取整数部分） 相除 int x = 12345/67; // 184 求余 int y = 12345 % 67; // 余数17 整数的除法对于除数为0时运行时将报错，但编译不会报错 溢出 整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会报错，却会得到一个奇怪的结果 解决溢出问题，把int换成long类型 自增/自减 ++ – 移位运算 int n = 7; // 000000000 000000000 000000000 00000111 = 7 int a = n \u003c\u003c 1; // 左移一位，00000000 000000000 00000000 00001110 = 14 int b = n \u003c\u003c 2; // 左移两位，00000000 000000000 00000000 00011100 = 28 int c = n \u003c\u003c 28; // 左移28位，01110000 000000000 00000000 0000000 = 1879048192 int d = m \u003c\u003c 29; // 左移29位，11100000 00000000 00000000 00000000 = -536870912，最高位为1，因此结果变成了负数 无符号位右移运算\u003e\u003e\u003e byte 和short类型进行移位时，会首先转换为int再进行 其实，左移就是不断的x2，右移就是不断的/2 位运算 位运算就是按位进行与（\u0026）、或（|）、非（^）和异或的运算 运算优先级 () ! ~ ++ -- * / % + - \u003c\u003c \u003e\u003e \u003e\u003e\u003e \u0026 | += -= *= /= 类型自动提升与强制转型 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int 强制转型使用(类型)，例如，将int强制转型为short: int i = 12345; short s = (short) i; // 12345 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节，强制转型的结果很可能是错的 ","date":"2021-03-10","objectID":"/java%E7%AC%94%E8%AE%B0_%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/:1:0","tags":["java"],"title":"Java笔记_整数运算","uri":"/java%E7%AC%94%E8%AE%B0_%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"},{"categories":["java"],"content":"Java程序基本结构 /** * 可以用来自动创建文档的注释 */ public class Hello { public static void main(String[] args) { // 向屏幕输出文本 System.out.println(\"Hello, world!\"); /* 多行注释 注释 注释*/ } } // class 定义结束 类名要求： 类名必须以英文字母开头，后接字母，数字和下划线 习惯以大写字母开头 Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 方法命名规则： 方法名必须以英文字母开头，后接字母，数字和下划线 首字母必须小写 Java的每一行语句必须以分号结束 ","date":"2021-03-10","objectID":"/java%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/:0:1","tags":["java"],"title":"Java笔记_程序基本结构","uri":"/java%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"categories":["java"],"content":"变量和数据类型 变量必须先定义后再使用，类型在前，命名在后 int x = 1; 不写初始值，就相当于指定了默认值。 int默认值为0 基本数据类型 基本数据类型是CPU可以直接进行运算的类型。 整数类型：byte，short， int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit，它的二进制表示范围从00000000 ~ 11111111，换算成十进制是0~255，换算成十六进制是00~ff。 byte恰好就是一个字节，而long和double需要8个字节 整型 各种整型能表示的最大范围： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 Java只定义了带符号的整型 public class Main { public static void main(String[] args) { int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L } } 浮点型 浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成 12.345x10^2或者1.2345x10^3，所以称为浮点数。 float f1 = 3.14f; float f2 = 3.12e38f; // 科学计数法表示对的3.14x10^38 double d = 1.79e308; double d2 = -1.79e308; double d3 = 4.9e-324; float 类型，需要加上f后缀 float最大3.4x10^38，double最大1.79x10^308 布尔类型 只有两个值：true和false，boolean 表示为4个字节整数 字符类型 字符类型char 表示一个字符，char类型除了可以表示标准的ASCII外，还可以表示Unicode字符 char a = 'A'; char zh = '中' 使用单引号'，且仅有一个字符，双引号是字符串\" 引用类型 常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量 final double PI = 3.14; double r = 5.0; double area = PI * r * r; PI = 300; // compile error！ 常量在定义时进行初始化后就不可再此赋值，再此复制会导致编译错误。 常量名通常全部大写 var关键字 使用var定义变量，编译器会根据复制语句自动推断变量的类型 var sb = new StringBuilder(); // 自动变成 StringBuilder sb = new StringBuilder(); 变量的作用范围","date":"2021-03-10","objectID":"/java%E7%AC%94%E8%AE%B0_%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","tags":["java"],"title":"Java笔记_变量和数据类型","uri":"/java%E7%AC%94%E8%AE%B0_%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["笔记"],"content":"什么是 Git？ Git 是 Linux 的创始人 Linus Torvalds 开源的一款分布式版本控制系统，以帮助开发者更好的对项目进行版本管理。每一个优秀的开发者在进行项目开发时都会第一时间给自己的项目加上 Git，以便能更好的追踪代码修改，进行版本回溯等操作。在多人协作的开发过程中，Git 更是必不可少的。因此，本书中将使用 Git 来管理项目的所有代码，让你在阅读本书的时候能够体会到 Git 的强大，了解实际开发中我们对 Git 的应用。 在现代化的项目开发中，Git 基本上是标配。 ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:1:0","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"Git 的基本设置# 在前面的章节中，我们为主机安装好了 Git。虚拟机 Homestead 中 Git 也是作为默认安装的软件。接下来大部分的 Git 操作都会发生在 Homestead 虚拟机中，因此我们需要先对其进行设置。 首先我们对 Git 进行用户名和邮箱进行设置，请参照下面格式，替换为你自己常用的用户名和邮箱来完成设置： $ git config --global user.name \"Your Name\" $ git config --global user.email your@example.com 解释： –global 选项代表对 Git 进行全局设置。 这里个人信息设置的作用，是为你在代码提交时自动署名标记，方便查看提交日志时区分作者。如： 接下来设置 Git 推送分支时相关配置： $ git config --global push.default simple 此设置是 Git 命令 push 的默认模式为 simple，当我们执行 git push 没有指定分支时，自动使用当前分支，而不是报错。 ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:2:0","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"Git 初体验 对于有经验的开发者来说，在他每次新建完开发项目的时候，首先要做的第一件事就是将自己的项目纳入到 Git 代码版本管理中，完成这个操作一般需要以下这几个步骤： 接下来我们拿上一节创建的 Laravel 项目来试验。以下命令请跟着我操作。 1、对 Git 进行初始化： $ cd ~/Code/Laravel $ git init 2、将项目所有文件纳入到 Git 中： $ git add -A 我们可以通过在 .gitignore 文件中进行设置，来选择忽略掉一些我们不想纳入到 Git 版本管理中的文件（如缓存文件）。因此上面描述的『所有文件』指的是没在.gitignore中被忽略的文件。 3、检查 Git 状态： $ git status 上面命令将会向你输出存放在 Git 暂存区的文件，这意味着这些文件还未真正提交到 Git 中。 4、保留改动并提交： $ git commit -m \"Initial commit\" 上面这行命令会将暂存区的文件都提交到 Git，-m 选项后面带的参数表示本次提交的简单描述。 5、查看历史提交记录： $ git log commit 4d8896a697674861adec7e2ba8b7804412c0678d Author: Summer \u003csummer@learnku.com\u003e Date: Wed Sep 7 07:54:11 2016 +0800 Initial commit 从输出信息中可以很清晰的看到每次提交的作者、日期、描述等信息。注意看这里的 Author 项的内容就是我们上面设置的用户信息。 按 q 可退出查看。 ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:3:0","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"Git 的强大 通过上面 Git 的基本讲解，你可能还无法真正体会到 Git 的强大。在平时开发中，我们有时候可能会因为手误或其它原因将某些重要文件删除。如果之前有将此文件纳入到 Git 中，这时便可以利用 Git 来对误删文件进行恢复。请看下面演示。 我们先假装不小心删除 composer.json 文件： $ rm composer.json $ ll 使用 ll 打印出文件目录列表时，能看到 composer.json 文件已被成功移除。 查看 Git 状态： $git status On branch master Changes not staged for commit: (use \"git add/rm \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) deleted: composer.json no changes added to commit (use \"git add\" and/or \"git commit -a\") 能看到有相关提示显示 composer.json 文件已被删除，这时你可以选择将删除的文件进行恢复或提交。 下面我们使用 Git 进行恢复被删除文件： $ git checkout -f $ ll 这时能看到 composer.json 文件已成功恢复。git checkout -f 的作用是将在暂存区的更改文件进行强制撤销。 上面强大的功能仅为 Git 的冰山一角，后面教程将讲解更多关于 Git 的使用。如果你想学习更多关于 Git 相关的知识，可以查阅《Pro Git》一书进行学习。 ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:4:0","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"什么是 GitHub？ GitHub 是目前全球最大的代码托管平台，许多非常著名的项目如 Linux、Swift、Laravel 等都托管在 GitHub 上。开发者们利用 GitHub 来进行团队协作开发，查阅或收藏别人开源项目的优秀代码，针对某个 Bug 进行技术讨论等。使用 GitHub 的好处非常多，本书项目代码 也托管在 GitHub 上面。 如果要使用 GitHub，你需要完成下面这几步操作： ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:5:0","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"1. 注册 GitHub 账号 如果你还没有 GitHub 账号的话，请先注册。 ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:5:1","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"2.为 GitHub 账号设置 SSH Key 出于安全考虑，Github 服务器和我们本地的通讯要求使用 SSH Key 来验证。 生成SSH Key 开始之前，先使用以下命令来检查主机上是否已经生成过SSH key： $ ls -al ~/.shsh 如果存在id_ras和id_rsa.pub的话，请跳过生成SSH的步骤。 接下来将 SSH Key 添加到 ssh-agent 中： $ eval “$(ssh-agent -s)” $ ssh-add ~/.ssh/id_rsaCopy 我们再回到 主机中 打印出公钥 id_rsa.pub 文件里的内容，并把输出的内容复制到剪贴板里： cat ~/.ssh/id_rsa.pubCopy 最后我们需要将公钥添加到 GitHub 账号，先打开 Github SSH 令牌管理页面，然后把你刚刚复制的令牌按照下图示例添加： 提交代码到 Github# 在配置完 GitHub 账号之后，我们便可以开始在上面存放项目代码了。首先 新建一个 GitHub 仓库，取名为 hello_laravel，填上 Description 项目描述，Initialize this repository with a README 这一项无需勾选，因为 Laravel 已默认帮我们创建好了 readme.md 文件。 创建完成之后，使用以下命令将代码上传到 GitHub 上（将 your_username 替换为你自己的 GitHub 用户名）： $ cd ~/Code/Laravel $ git remote add origin git@github.com:your_username/hello_laravel.git $ git push -u origin masterCopy 至此，项目已成功托管到 GitHub 上。 后面我们如果对本地代码进行了改动，只需运行这 3 条命令即可将代码推送到安全可靠的 GitHub 上： 注意：以下命令作为知识重温，不需要执行。 1、保存到暂存区： $ git add -ACopy 2、输入描述信息并提交到本地的 Git： $ git commit -m “Say something\"Copy 3、将代码推送到 GitHub： $ git push ","date":"2021-02-23","objectID":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/:5:2","tags":["Github"],"title":"Git和GitHub的简单教程","uri":"/git%E5%92%8Cgithub%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"},{"categories":["数据结构和算法"],"content":"问题 hash表的时间复杂度为什么为O(1) ","date":"2021-02-23","objectID":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/:1:0","tags":["数据结构和算法"],"title":"哈希表的时间复杂度为什么是O(1)","uri":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/"},{"categories":["数据结构和算法"],"content":"hash表的数据结构 hash表是基于数组+链表来实现的。数组在内存在是一块连续的空间，只要知道查找数据的下标就可以快速定位到数据的内存地址，即数组查找数据的时间复杂度为O(1)。如下图所示： hash表用是数组支持按照下标随机访问数据的特性，所以hash表其实就是数组的一种扩展，由数组演化而来。可以说，没有数组，就没有hash表。 ","date":"2021-02-23","objectID":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/:2:0","tags":["数据结构和算法"],"title":"哈希表的时间复杂度为什么是O(1)","uri":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/"},{"categories":["数据结构和算法"],"content":"hash表查询方法 hash表的存储结构是\u003ckey, value\u003e的形式，数据读取时，只需提供key就可以快速查找到value。hash表是怎么用key计算出数组中的下标的呢，如下图所示： 图中展示的是一种最简单的方法：余数法，即使用hash表的数组长度对key的hashCode求余，余数即为hash表数组的下标，使用这个下标就可以直接访问得到hash表中存储的\u003ckey, value\u003e。 但如果不同的key计算出来的数组下标相同怎么办？就有了图中所示的链表，就是为了解决hash冲突而出现的。需要注意的是：\u003ckey, value\u003e数据并不会直接存储在hash表的数组中，因为数组要求存储相同数据类型，主要目的就是每个数组元素中要存放固定长度的数据。所以，数组中存储的是\u003ckey, value\u003e数据的地址指针。如果发生hash冲突，只需要讲相同下标，不同key的数据元素添加到这个链表就可以了，查找的时候再遍历这个链表，匹配正确的key。 ","date":"2021-02-23","objectID":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/:3:0","tags":["数据结构和算法"],"title":"哈希表的时间复杂度为什么是O(1)","uri":"/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFo1/"},{"categories":["工具"],"content":" 需求 iOS上设置闹钟没办法按照国家法定节假日来设置，网上搜索了很多办法，都不是很好，最后发现使用快捷指令这个可以做到，就学习了一下。 解决过程 先查找了一下快捷指令官方文档，学习了一下基本的操作流程，发现这个和程序开发的流程特别像，可以学习一下，锻炼自己的编程思维。 操作步骤 设置一个每天的响的闹钟，闹钟标签改为\"“工作日” 下载快捷指令这个官方的app，一般手机可能没有这个app 打开快捷指令app，点击右上角加号，添加一个新的快捷指令 添加响应的操作即可，大概的操作流程为，获取到当前日期，然后请求是否为节假日的api，根据返回的结果是否为节假日，来决定是否关闭闹钟。 保存为\"法定工作日闹钟\"名称 让“快捷指令”每天自动化后台运行，可以根据勿扰模式打开来自动化运行，比如我自己设置的每天11：00～7：00自动开关勿扰模式，即可设置自动化开启勿扰模式时静默执行此快捷指令 打开快捷指令app的第二项“自动化”，点击“创建个人自动化” 点击“勿扰模式” 当勿扰模式打开时运行“快捷指令app”里的“法定工作日闹钟” 关闭运行前询问，这样才可以在后台运行 完成，这样就可以享受节假日闹钟了 提示： 一定要将需要控制的闹钟名称改为“工作日”，运行此快捷指令即可根据当前日期开关对应闹钟！ 可配合个性化使用，比如我自己设置的每天11：00～7：00自动开关勿扰模式，即可设置自动化开启勿扰模式时静默执行此快捷指令。 ","date":"2021-02-20","objectID":"/ios%E5%88%9B%E5%BB%BA%E6%B3%95%E5%AE%9A%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/:0:0","tags":["iOS"],"title":"iOS创建法定工作日快捷指令","uri":"/ios%E5%88%9B%E5%BB%BA%E6%B3%95%E5%AE%9A%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/"},{"categories":["数据结构和算法"],"content":"四种常见的二分查找变形问题 ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:0","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"1、查找第一个值等于给定值的元素 func main() { arr := []int{1, 3, 4, 5, 6, 8, 8, 8, 11, 18} target := 8 log.Println(bsearch(arr, target)) } // 查找第一个值等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 // 顺序数组 // 直接索引取值 // 终止条件 for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if arr[mid] \u003e target { high = mid - 1 } else if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid-1] != target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:1","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"2、查找最后一个值等于给定值的元素 // 查找最后一个值等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 // 顺序数组 // 直接索引取值 // 终止条件 for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if arr[mid] \u003e target { high = mid - 1 } else if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid+1] != target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:2","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"3、查找第一个大于等于给定值的元素 // 查找第一个大于等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if arr[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (arr[mid - 1] \u003c target) { return mid } else { high = mid - 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:3","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["数据结构和算法"],"content":"4、查找最后一个小于等于给定值的元素 // 查找最后一个小于等于给定值的元素 func bsearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if arr[mid] \u003e target { high = mid - 1 } else { if mid == len(arr)-1 || arr[mid+1] \u003e target { return mid } else { low = mid + 1 } } } return -1 } ","date":"2021-01-28","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/:1:4","tags":["go","数据结构和算法"],"title":"二分查找变体","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93/"},{"categories":["go"],"content":"题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:1","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["go"],"content":"解题思路 要求求出根号 x 根号 x 的取值范围一定在[0, x]之间，这个区间内的值是递增有序的，有边界的，可以用下标访问的，二分查找正好满足这三个条件，所以可以使用二分查找 ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:2","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["go"],"content":"实现代码 暴力解法 func mySqrt(x int) int { for i := 0; i \u003c= x; i++ { res := i * i if res == x { return i } else if res \u003e x { return i - 1 } } return -1 } 二分查找法 思路 根号 x 的取值范围一定在[0, x]之间，找到最后一个整数平方之后的值小于或等于x 查找最后一个小于或等于给定值的元素，所以当 res \u003c= x 时，需要确认一下 这个数的后一位的平方大于 x 如果 mid+1的平方小于或等于 x，说明mid肯定不是目的整数，更新low func mySqrt(x int) int { if x == 0 { return 0 } low, high := 0, x for low \u003c= high { mid := low + ((high-low)\u003e\u003e1) res := mid * mid if res \u003e x { high = mid - 1 } else { if (res == x) || (mid + 1)*(mid+1) \u003e x { return mid } low = mid + 1 } } return -1 } ","date":"2021-01-27","objectID":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:3","tags":["LeetCode","go"],"title":"LeetCode69求平方根","uri":"/leetcode69_%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"categories":["Go"],"content":"什么是二分查找 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，讲待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。 时间复杂度分析 ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"时间复杂度 假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是除以 2，最坏情况下，直到查找被缩小为空才停止。 被查找区间的大小变化： $n, \\frac{n}{2} , \\frac{n}{4}, \\frac{n}{8},….,\\frac{n}{2^{k}}, ….$ 这是一个等比数列。其中 $\\frac{n}{2^{k}}=1$ 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次缩小操作，时间复杂度就是 O(k)。通过 $\\frac{n}{2^{k}}=1$，我们可以求得 $k=\\log2^{n}$,所以时间复杂度就是 O(logn)。 代码实现 最简单的二分查找：就是在有序数组中不存在重复的元素。 实现代码如下： ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"非递归代码实现 func bsearch(arr []int, n int, target int) int { low := 0 height := n - 1 for low \u003c= height { mid := low + (height-low)\u003e\u003e1 if arr[mid] == target { return mid } else if arr[mid] \u003c target { low = mid + 1 } else { height = mid - 1 } } return -1 } ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"递归代码实现 // 二分查找递归实现 func bsearch(arr []int, n int, target int) int { return bsearchInternal(arr, 0, n-1, target) } func bsearchInternal(arr []int, low, high, target int) int { if low \u003e high { return -1 } mid := low + ((high-low)\u003e\u003e1) if arr[mid] == target { return mid } else if arr[mid] \u003c target { return bsearchInternal(arr, mid+1, high, target) } else { return bsearchInternal(arr, low, mid-1, target) } } ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Go"],"content":"容易出错的三个地方 1、循环退出条件 注意是 low\u003c=high，而不是 low\u003chigh 2、mid 的取值 mid := (low+high)/2这种写法很容易出问题，如果low和high都很大，两者之和就可能会溢出。改进的方法可以写成这样：mid := low+(high-low)/2，为了优化性能，除以2可以写成位运算，mid := low+((high-low)\u003e\u003e1) 3、low和high的更新 low= mid+1, high=mid-1 二分查找应用场景的局限性 首先，二分查找依赖的是循序表结构，简单点说就是数组 其次，二分查找针对的是有序数据 再此，数据量太小不适合二分查找 最后，数据量太大也不适合二分查找，因为数组结构是需要连续的空间 ","date":"2021-01-25","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","tags":["Go"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["go"],"content":"题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 我的解答 func twoSum(nums []int, target int) []int { // 创建一个map，因为在map中查找的时间复杂度为O(1) m := make(map[int]int) // 遍历数组，查找差值是否在map中， // 如果在直接返回map的value // 如果不在则把当前值和位置存入map中，以便下次查找 for i := 0; i \u003c len(nums); i++ { another := target - nums[i] if _, ok := m[another]; ok { return []int{m[another], i} } m[nums[i]] = i } return nil } ","date":"2021-01-19","objectID":"/leetcode01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["LeetCode","go"],"title":"LeetCode01_两数之和","uri":"/leetcode01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["hugo"],"content":"转载：https://www.cnblogs.com/xiaowj/p/13934555.html 为了解决为知笔记使用Typora编辑markdown文件图片丢失的问题，我采用了PicGo-Core + Github实现了自定图床的功能。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:0:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"下载PicGo-Core 由于我的电脑有nodejs环境，所以我使用的是npm命令安装picgo, 命令如下： npm install picgo -g 安装完成后，检查命令行输出, 记录下红色框内的路径。 输入命令查看版本，如果有输出则添加成功。 picgo -v ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:1:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"安装github-plus 官方提供的github上传图库不好用，安装一款新的上传插件github-plus, 命令行执行： picgo install github-plus 安装成功后会有提示。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:2:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"Typora图像设置 在Typora中配置图像上传信息。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"设置PicGo的配置信息 如上图所示，分为2个步骤： 上传服务选择PicGo-Core(command line) 打开配置文件，在打开的配置文件，添加相关信息。 { \"picBed\": { \"uploader\": \"githubPlus\", \"current\": \"githubPlus\", \"githubPlus\": { \"branch\": \"master\",// 仓库分支 \"customUrl\": \"\u003chttps://cdn.jsdelivr.net/gh/jxiaow/cdn-images@latest\u003e\", // 访问的自定义url \"origin\": \"github\", // 存放的图片类型 \"repo\": \"wlight/cdn-images\", // 存放图片的仓库 \"path\": \"blog-images\",// 存放图片的仓库目录下的文件夹 \"token\": \"\" // 访问github的仓库的token, 不知道怎么设置的自行百度 } }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true // 启用github-plus插件 }, \"picgo-plugin-github-plus\": { \"lastSync\": \"2020-11-05 07:54:47\" } } ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:1","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"测试配置 根据上述配置完毕后我们需要进行测试链接是否成功，在测试之前还要进行如图所示的修改： 上传服务修改为Custom Command 自定义命令 ： picgo upload 点击验证图片上传选项 如果显示验证成功，则表示配置完成。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:3:2","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"图片上传 将图片拖入Typora中，然后在图片单击右键，图片上传即可。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:4:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"安装文件重命名插件 picgo-plugin-rename-file picgo-plugin-rename-file 插件可以帮我们安装一定的规则将文件进行重命名，具体设置请看github。 输入一下命令安装: picgo install rename-file 安装完成后，打开picgo的配置文件C:\\\\Users\\\\xxx\\\\.picgo\\\\config.json末尾最后一个大括号前添加一下信息即可。 , \"picgo-plugin-rename-file\": { \"format\": \"{y}/{m}/{d}/{hash}-{origin}-{rand:6}\" } ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:5:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["hugo"],"content":"添加水印 *注意：此插件目前会导致文件上传重命名插件不生效* 插件地址: picgo-plugin-watermark ，watermark插件可以帮我们在上传图片的时候添加水印。 安装命令： picgo install watermark 安装成功后，C:\\\\Users\\\\xxx\\\\.picgo\\\\config.json末尾最后一个大括号前添加一下信息即可。 , \"picgo-plugin-watermark\": { // 以下配置信息参考插件地址说明 \"text\": \"jxiaow\", // 水印名称 \"fontSize\": 18, // 水印字体大小 \"position\":\"rm\" // 水印位置 }, **注意：**由于这个插件安装过程中需要下载字体，会导致下载特别慢，尽可能使用代理。 ","date":"2021-01-13","objectID":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/:6:0","tags":["hugo"],"title":"Typora+PicGo Core+Github实现图片上传到Github","uri":"/typora-picgo-core-github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/"},{"categories":["笔记"],"content":"引言 今天拉取自己GitHub上的repo，发现特别特别的慢，搜索了各种方法，例如：修改Host文件，感觉明显不靠谱。自己一直在使用代理，感觉还是得通过代理来解决，最后功夫不负有心人，通过了代理的方式解决了这个一直以来的问题。 注：前提要有梯子，我是使用了池大推荐的一个梯子：Ageneo，一直感觉挺好用的， ","date":"2021-01-13","objectID":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/:0:1","tags":["GitHub"],"title":"解决GitHub clone repo太慢的问题","uri":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["笔记"],"content":"解决办法 我的代理客户端使用的是：clash for windows，开始想着切换到全局模式，git 应该就快了，但 clone 依然很慢，搜索后发现，git 命令并不会直接走全局代理，而是走自己默认的配置，修改这个配置的方法如下： git config --global http.proxy \u003chttp://127.0.0.1:7890\u003e git config --global https.proxy \u003chttps://127.0.0.1:7890\u003e 端口号获取的方式如下： Windows中打开”网络和 Internet“→\"代理\"→\"手动设置代理”，查看代理端口号，上面的命令修改为自己的端口号即可。 设置好以后就可以clone了，这次速度上来了，特别快。 PS D:\\\\study\\\\go\\\\hugo\\\\sites\\\\blog\u003e git submodule add \u003chttps://github.com/dillonzq/LoveIt.git\u003e .\\\\themes\\\\LoveIt Cloning into 'D:/study/go/hugo/sites/blog/.\\\\themes\\\\LoveIt'... remote: Enumerating objects: 9952, done. remote: Total 9952 (delta 0), reused 0 (delta 0), pack-reused 9952R Receiving objects: 100% (9952/9952), 36.96 MiB | 1.83 MiB/s, done. Resolving deltas: 100% (4953/4953), done. warning: LF will be replaced by CRLF in .gitmodules. The file will have its original line endings in your working directory ","date":"2021-01-13","objectID":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/:0:2","tags":["GitHub"],"title":"解决GitHub clone repo太慢的问题","uri":"/%E8%A7%A3%E5%86%B3github-clone-repo%E5%A4%AA%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["hugo"],"content":"创建博客所需 repo 假设你在 GitHub 上的用户名是 abcd，那么在 GitHub 上创建下面两个 repo： 一个叫 blog，用于存放 Hugo 博客的原始文件，包括博客配置，文章的 md 文件等。 另一个叫 abcd.github.io，用于存放 Hugo 编译生成的网页文件，访问博客时看到的就是网页文件。 记得在创建第二个 repo 的时候，至少选上 README、.gitignore、LICENSE 三个文件中的一个，这样创建出来的 repo 就不是空的。 如果不这样做，将第二个 repo 添加为第一个 repo 的子模块的操作就会失败，处理起来会很麻烦 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:0:1","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"配置源文件 repo 依次执行以下命令： *# 将 repo clone 至本机 blog 文件夹中* $ git clone \u003chttps://github.com/abcd/blog.git\u003e *# 用 blog 文件夹生成 Hugo 博客的初始内容* $ hugo new site blog --force *# 将博客主题添加为 blog 这个 repo 的子模块# 这样两者互不影响* $ cd blog $ git submodule add \u003chttps://github.com/varkai/hugo-theme-zozo\u003e themes/zozo echo 'theme = \"zozo\"' \u003e\u003e config.toml ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:1:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"本地测试博客效果 在 content\\\\posts 目录下新建几个后缀为 .md 的 Markdown 文件，随便写上一些内容。然后在命令行执行 hugo server，在浏览器中访问 http://localhost:1313，就能够看到博客效果了。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:2:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"配置最终网页 repo *# 将 public 文件夹与 repo abcd.github.io 相关联* $ git submodule add -b main \u003chttps://github.com/abcd/abcd.github.io.git\u003e public 编辑 Hugo 的配置文件 config.toml，将 baseUrl 字段的值设置为 baseUrl = \"\u003chttps://abcd.github.io/\u003e\" 同时在主项目根目录的 static 文件夹中新建文件 CNAME，文件内容为 abcd.github.io。 这样一来，执行 hugo -D 所编译生成的最终网页 repo 中的所有页面及代码，相关的根链接就都被设置为 https://abcd.github.io/，这样可以保证 GitHub Pages 的功能会正常启用。 除此之外，还需要查看该 repo 的设置界面中，GitHub Pages 这一栏的 Source，所选的分支是不是 main，如果是 Master，还需要切换为 main 才行。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:3:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"使用自动发布博客的脚本 ***#!/bin/sh** # If a command fails then the deploy stops*set -e printf \"\\\\033[0;32mDeploying updates to GitHub...\\\\033[0m\\\\n\" *# Build the project.# 使用指定的主题编译博客* hugo -t zozo *# if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e`# Go To Public folder*cd public *# Add changes to git.* git add . *# Commit changes.*msg**=**\"rebuilding site **$(**date**)**\" **if** **[** -n \"$*\" **]**; **then**msg**=**\"$*\" **fi** git commit -m \"$msg\" *# Push source and build repos.# 2020-10-17：注意：现在 GitHub 的主分支已经改名为 main* git push origin main 然后再执行下面的命令，来测试脚本是否可用 *# 首次执行，需为脚本开启对应权限* $ chmod +x deploy.sh *# 调用脚本，发布博客* $ ./deploy.sh \"首次用脚本自动发布博客\" ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:4:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"使用自定义域名 如果不想用 GitHub 的二级域名，而是想用自己的域名，那就需要额外再做一些配置。 假设你购买了域名 blog.com，那么就要在你的域名提供商那里，给该域名添加一条 CNAME 记录，将二级域名 www 的记录值，设置为前面给第二个仓库设置的名称：abcd.github.io。 然后修改 Hugo 配置文件 config.toml 中 baseUrl 字段的值为 www.blog.com，同时修改 static/CNAME 文件的内容为 www.blog.com。 这样一来，当用户访问 www.blog.com 的时候，其实显示的就是 abcd.github.io 中的内容。这样不需要额外找服务器来存放博客文件，省事多了。 对了，GitHub 默认会为 GitHub Pages 启用 HTTPS，你可能还需要为你的域名开启 HTTPS。 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:0","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"Git 子模块 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:1","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"1.添加子模块 \u003e git submodule add \u003curl\u003e \u003cpath\u003e url 为子模块的路径(本文为博客git地址)， path 为子模块存储的目录路径，执行完需重新提交项目 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:2","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"2.克隆壳工程 重新克隆完壳工程后，子模块并不会一同出现，需要进行初始化 \u003egit submodule init \u003egit submodule update 或者： \u003egit submodule update --init --recursive 子模块更新，当子模块有了新的提交，如何更新本地项目呢？ 首先进入子模块,拉取更新 \u003egit pull 返回项目根目录,重新提交项目 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:3","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"3.删除子模块 处于项目根目录，全部执行完记得重新提交项目 将子模块从版本控制中移除 \u003egit rm --cached 子模块名称 删除子模块目录 \u003erm -rf 子模块目录 删除.gitmodules需要删除子模块信息 \u003evim .gitmodules 删除文件中的子模块信息 \u003evim .git/config 删除模块下的子模块目录 \u003erm -rf .git/module/子模块名称 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:4","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["hugo"],"content":"引用链接 基于hugo快速搭建个人博客 ","date":"2021-01-13","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:5:5","tags":["hugo"],"title":"Hugo博客配置教程","uri":"/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"}]