# Java笔记_面向对象基础


<!--more-->

Java 面向对象的语言，面向对象编程OOP(Object-Oriented Programming)

### 基础

`class`和`instance`是模板和实例的关系；

定义`class`就是定义了一种数据类型，对应的`instance`是这种数据类型的实例；

`class`定义的`field`，在每个`instance`都会拥有各自的`field`，且互不干扰；

通过`new`操作符创建新的`instance`，然后用变量指向它，即可通过变量来引用这个`instance`；

访问实例字段的方法是变量名.字段名；

指向`instance`的变量都是引用变量；

### 方法

#### 定义方法

```java
修饰符 方法返回类型 方法名(方法参数列表) {
    若干方法语句;
    return 方法返回值;
}
```

> 返回类型如果为`void`，可以省略`return`

#### 修饰符

private：不允许外部调用，只有类内部调用

public：公开的，都可以调用

#### this

始终指向当前实例，如果没有命名冲突，可以省略`this`,如果局部变量和字段重名，那么局部变量优先级更高，所以必须加`this`

#### 方法参数

方法可以包含0个或任意个参数。方法参数用于

### 构造方法

构造方法的名称就是类名，构造方法的参数没有限制，在方法内部，也可以便谢任意语句。但是构造方法没有返回值（也没有void），调用构造方法，必须使用`new`操作符。

### 方法重载

在一个类中，我们可以定义多个方法，如果有一系列方法，他们的功能都是类似的，只有参数不同，那么，可以把这一组方法做成同名方法。就是重载（Overload）

> 方法重载的返回值类型通常都是相同的

方法重载的目的是：功能类似的方法使用同一个名字，更容易记住，调用起来更简单。

### 继承

使用`extends`来继承，

**子类自动获得父类的所有字段，严禁定义与父类重名的字段**

#### 继承树

所有的类如果没有父类，都是继承自`Object`类

一个类有且仅有一个父类，单继承

#### Protected

子类无法访问父类的`private`字段或者`private`方法

为了让子类可以访问父类的字段，我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问。

`protected`关键字可以把字段和方法访问权限控制在继承树内部。

#### super

子类引用父类的字段时，可以用`super.fieldName`。等同于`this.name`或者`name`。

如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便编译器定位到父类的一个合适的构造方法。

**子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。**

#### 阻止继承

`final`不允许继承

#### 向上/向下转型

向上转型：把一个子类实例强制转成父类实例，是安全的，因为子类拥有父类所有的功能

向下转型：把一个父类实例强制转为子类实例，需要使用`instanceof`来判断一个实例是不是某个类型。（Java14使用之后直接转换成对应的类型）

#### 继承和组合

Student是Person的一种，它们是is关系，而Student并不是Book，Student和Book的关系是has关系。

拥有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例

```java
class Student extends Person {
    protected Book book;
    protected int score;
}
```

### 多态

在继承关系中，子类如果定义了一个父类方法签名完全相同的方法，被称为覆写（override）

如果方法签名不同，就是`Overload`，`Overload`方法就是一个新的方法。

如果方法签名相同，返回值也相同，就是`Override`

**注意：方法名相同，方法参数相同，但返回值不同，也是不同的方法。在Java中，出现这种情况，编译器会报错。**

```java
class Person {
    public void run(){}
}

class Student extends Person {
    // 加上@Override 可以让编译器帮助检查是否进行了正确的覆写
    @Override
    public void run(){}
}
```

多态就是，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：

```java
Person p = new Student();
p.run(); // 无法确定运行时究竟调用哪个run()方法
```


