# Java笔记_整数运算


<!--more-->

## 整数运算

#### 基本运算

遵循四则运算法则

整数的数值表示时精确的，整数运算也永远是精确的，即使是除法也是精确的（两数相除只取整数部分）

相除

```java
int x = 12345/67; // 184
```

求余

```java
int y = 12345 % 67; // 余数17
```

> 整数的除法对于除数为0时运行时将报错，但编译不会报错

#### 溢出

整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会报错，却会得到一个奇怪的结果

解决溢出问题，把int换成long类型

#### 自增/自减

++ -- 

#### 移位运算

```java
int n = 7;	// 000000000 000000000 000000000 00000111 = 7
int a = n << 1; // 左移一位，00000000 000000000 00000000 00001110 = 14
int b = n << 2; // 左移两位，00000000 000000000 00000000 00011100 = 28
int c = n << 28; // 左移28位，01110000 000000000 00000000 0000000 = 1879048192
int d = m << 29; // 左移29位，11100000 00000000 00000000 00000000 = -536870912，最高位为1，因此结果变成了负数
```

无符号位右移运算`>>>`

byte 和`short`类型进行移位时，会首先转换为int再进行

> 其实，左移就是不断的x2，右移就是不断的/2

#### 位运算

位运算就是按位进行与（&）、或（|）、非（^）和异或的运算

#### 运算优先级

- `()`
- `!` `~` `++` `--`
- `*` `/` `%`
- `+` `-`
- `<<` `>>` `>>>`
- `&`
- `|`
- `+=` `-=` `*=` `/=`

#### 类型自动提升与强制转型

在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，`short`和`int`计算，结果总是`int`，原因是`short`首先自动被转型为`int`

强制转型使用`(类型)`，例如，将`int`强制转型为`short`:

```java
int i = 12345;
short s = (short) i; // 12345
```

> 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，`int`的两个高位字节直接被扔掉，仅保留了低位的两个字节，强制转型的结果很可能是错的


